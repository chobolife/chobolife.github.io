<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-08-05T18:44:36+09:00</updated><id>/feed.xml</id><title type="html">우당탕탕 초보라이프</title><subtitle>An amazing website.</subtitle><author><name>Your Name</name></author><entry><title type="html">EC2에서 S3에 접근하는 방법</title><link href="/blog/2019/08/04/ec2-s3-authority/" rel="alternate" type="text/html" title="EC2에서 S3에 접근하는 방법" /><published>2019-08-04T15:15:00+09:00</published><updated>2019-08-04T15:15:00+09:00</updated><id>/blog/2019/08/04/ec2-s3-authority</id><content type="html" xml:base="/blog/2019/08/04/ec2-s3-authority/">&lt;h1 id=&quot;jekyll-블로그의-초안을-aws-s3에-업로드&quot;&gt;Jekyll 블로그의 초안을 AWS S3에 업로드&lt;/h1&gt;
&lt;p&gt;이전 포스팅(&lt;a href=&quot;/blog/2019/08/01/jekyll-draft/&quot;&gt;Jekyll 초안 관리에 대한 고민&lt;/a&gt;)에서 했던 고민의 결론은 &lt;em&gt;‘Jekyll 블로그의 초안을 github page에 commit하기 전에 AWS S3에 업로드해서 나만 먼저 확인해보겠다’&lt;/em&gt;는 것이었다.
그리고 그것을 위해 약간의 삽질을 했지만 결국 AWS CLI를 이용하여 ubuntu에서 S3에 업로드하는 방법을 찾았다.
이번 포스팅에서는 그 방법을 정리해 두려고 한다.&lt;/p&gt;

&lt;p&gt;참고로 Jekyll 블로그를 S3에서 호스팅하는 것이 목적이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;s3_website&lt;/code&gt;라는 package로 아주 쉽게 할 수 있다.
하지만 지금 나는 Jekyll에서 생성한 블로그를 github pages에 호스팅하고 있으며, S3에는 초안 또는 수정사항만 공개하기 전에 내가 확인하려는 것이 목적이다.
그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리 밑에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 디렉토리가 있고, 여기에는 꽤 많은 폴더와 파일이 있는 상태이다.
이 상태에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;s3_website&lt;/code&gt;를 이용해서 S3 버킷에 올리면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 폴더에 있는 모든 폴더와 파일도 업로드되는데, 이는 S3에 상당한 용량을 차지할 뿐 아니라 많은 수의 PUT request를 발생시키게 된다.
그래서 나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;s3_website&lt;/code&gt;를 사용하지 않고 아래와 같이 awscli를 사용하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;ubuntu에-aws-cli-설치&quot;&gt;Ubuntu에 AWS CLI 설치&lt;/h1&gt;
&lt;p&gt;가장 먼저 해야 할 일은 ubuntu에 AWS CLI를 설치하는 것이다.
&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-install.html&quot;&gt;Amazon docs&lt;/a&gt;를 참고하면, &lt;strong&gt;사전 요구 사항&lt;/strong&gt;으로 Python을 설치해야 한다고 한다.
먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;python --version&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;python3 --version&lt;/code&gt;을 실행하여 파이썬이 설치되어 있는지 확인해 보고, 설치되어 있지 않다면 아래의 명령으로 파이썬을 설치하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이미 파이썬이 설치되어 있는 상태에서 위의 명령을 실행하면 아래와 같은 메시지가 출력된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reading package lists... Done
Building dependency tree
Reading state information... Done
python3 is already the newest version (3.6.7-1~18.04).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(사실 내가 이 메시지를 본 건… 파이썬이 설치되어 있을 줄 몰랐다. 내가 설치한 EC2 AMI에서는 python3가 이미 설치되어 있었다.)&lt;/p&gt;

&lt;p&gt;다음은 파이썬의 패키지 설치 관리자인 pip를 통해 awscli를 설치하면 된다.
&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-install.html&quot;&gt;Amazon docs&lt;/a&gt;에는 이렇게 설치하라고 나와 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install awscli --upgrade --user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 명령을 실행하면 awscli가 설치되며, 아래와 같이 설치 로그가 출력된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Collecting awscli
  Downloading https://files.pythonhosted.org/packages/6a/82/99ed4bfad39ace624a5a547b96e520b8f61a01348758c277f0a79aeeb315/awscli-1.16.209-py2.py3-none-any.whl (1.8MB)
    100% |                                | 1.8MB 806kB/s
Collecting rsa&amp;lt;=3.5.0,&amp;gt;=3.1.2 (from awscli)
  Downloading https://files.pythonhosted.org/packages/e1/ae/baedc9cb175552e95f3395c43055a6a5e125ae4d48a1d7a924baca83e92e/rsa-3.4.2-py2.py3-none-any.whl (46kB)
    100% |                                | 51kB 10.8MB/s
Collecting botocore==1.12.199 (from awscli)
  Downloading https://files.pythonhosted.org/packages/50/f8/dbe656ee191c2d8b471a86fa07f0d37515611d865deaa034fc2b71dd71e4/botocore-1.12.199-py2.py3-none-any.whl (5.6MB)
    100% |                                | 5.6MB 248kB/s
Collecting PyYAML&amp;lt;=5.1,&amp;gt;=3.10; python_version != &quot;2.6&quot; (from awscli)
  Downloading https://files.pythonhosted.org/packages/9f/2c/9417b5c774792634834e730932745bc09a7d36754ca00acf1ccd1ac2594d/PyYAML-5.1.tar.gz (274kB)
    100% |                                | 276kB 914kB/s
Collecting colorama&amp;lt;=0.3.9,&amp;gt;=0.2.5 (from awscli)
  Downloading https://files.pythonhosted.org/packages/db/c8/7dcf9dbcb22429512708fe3a547f8b6101c0d02137acbd892505aee57adf/colorama-0.3.9-py2.py3-none-any.whl
Collecting s3transfer&amp;lt;0.3.0,&amp;gt;=0.2.0 (from awscli)
  Downloading https://files.pythonhosted.org/packages/16/8a/1fc3dba0c4923c2a76e1ff0d52b305c44606da63f718d14d3231e21c51b0/s3transfer-0.2.1-py2.py3-none-any.whl (70kB)
    100% |                                | 71kB 10.3MB/s
Collecting docutils&amp;lt;0.15,&amp;gt;=0.10 (from awscli)
  Downloading https://files.pythonhosted.org/packages/36/fa/08e9e6e0e3cbd1d362c3bbee8d01d0aedb2155c4ac112b19ef3cae8eed8d/docutils-0.14-py3-none-any.whl (543kB)
    100% |                                | 552kB 2.5MB/s
Collecting pyasn1&amp;gt;=0.1.3 (from rsa&amp;lt;=3.5.0,&amp;gt;=3.1.2-&amp;gt;awscli)
  Downloading https://files.pythonhosted.org/packages/6a/6e/209351ec34b7d7807342e2bb6ff8a96eef1fd5dcac13bdbadf065c2bb55c/pyasn1-0.4.6-py2.py3-none-any.whl (75kB)
    100% |                                | 81kB 10.8MB/s
Collecting python-dateutil&amp;lt;3.0.0,&amp;gt;=2.1; python_version &amp;gt;= &quot;2.7&quot; (from botocore==1.12.199-&amp;gt;awscli)
  Downloading https://files.pythonhosted.org/packages/41/17/c62faccbfbd163c7f57f3844689e3a78bae1f403648a6afb1d0866d87fbb/python_dateutil-2.8.0-py2.py3-none-any.whl (226kB)
    100% |                                | 235kB 2.3MB/s
Collecting urllib3&amp;lt;1.26,&amp;gt;=1.20; python_version &amp;gt;= &quot;3.4&quot; (from botocore==1.12.199-&amp;gt;awscli)
  Downloading https://files.pythonhosted.org/packages/e6/60/247f23a7121ae632d62811ba7f273d0e58972d75e58a94d329d51550a47d/urllib3-1.25.3-py2.py3-none-any.whl (150kB)
    100% |                                | 153kB 7.7MB/s
Collecting jmespath&amp;lt;1.0.0,&amp;gt;=0.7.1 (from botocore==1.12.199-&amp;gt;awscli)
  Downloading https://files.pythonhosted.org/packages/83/94/7179c3832a6d45b266ddb2aac329e101367fbdb11f425f13771d27f225bb/jmespath-0.9.4-py2.py3-none-any.whl
Collecting six&amp;gt;=1.5 (from python-dateutil&amp;lt;3.0.0,&amp;gt;=2.1; python_version &amp;gt;= &quot;2.7&quot;-&amp;gt;botocore==1.12.199-&amp;gt;awscli)
  Downloading https://files.pythonhosted.org/packages/73/fb/00a976f728d0d1fecfe898238ce23f502a721c0ac0ecfedb80e0d88c64e9/six-1.12.0-py2.py3-none-any.whl
Building wheels for collected packages: PyYAML
  Running setup.py bdist_wheel for PyYAML ... done
  Stored in directory: /home/ubuntu/.cache/pip/wheels/ad/56/bc/1522f864feb2a358ea6f1a92b4798d69ac783a28e80567a18b
Successfully built PyYAML
Installing collected packages: pyasn1, rsa, docutils, six, python-dateutil, urllib3, jmespath, botocore, PyYAML, colorama, s3transfer, awscli
Successfully installed PyYAML-5.1 awscli-1.16.209 botocore-1.12.199 colorama-0.3.9 docutils-0.14 jmespath-0.9.4 pyasn1-0.4.6 python-dateutil-2.8.0 rsa-3.4.2 s3transfer-0.2.1 six-1.12.0 urllib3-1.25.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(사실 이 설치 로그가 중요한 것은 아닌데, 혹시 나중에 똑같은 과정을 수행할 때 문제가 있는지 없는지 확인하기 위한 용도로 남겨 두는 것이다.)&lt;/p&gt;

&lt;p&gt;그리고 나서 프롬프트가 떨어지면 awscli의 설치는 끝난 것이다.
하지만 모든 것이 끝난 것은 아니다.
이어서 해 주어야 하는 일이 있는데, 그것은 바로 어느 경로에서나 awscli를 실행할 수 있도록 설치 경로를 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;에 추가하는 것이다.
위와 같이 설치했다면 awscli는 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.local/bin&lt;/code&gt; 디렉토리 밑에 설치되어 있을 것이므로 이 경로를 추가해 주면 된다.&lt;/p&gt;

&lt;p&gt;awscli의 설치 경로를 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;에 추가해 주기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 파일을 열었다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;의 맨 마지막에는 지난 번 Jekyll을 설치하면서 편집했던 아래와 같은 내용이 있었다.
(&lt;a href=&quot;/blog/2019/07/27/start-jekyll-2/&quot;&gt;나의 Jekyll 여행기 (2)&lt;/a&gt; 참고)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Install Ruby Gems to ~/gems
export GEM_HOME=$HOME/gems
export PATH=$HOME/gems/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 그 아래와 같이 추가해 주었다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Install aws-cli to ~/.local/bin
export PATH=$HOME/.local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 나서 방금 수정한 내용을 현재 열려 있는 터미널에도 적용시키기 위해 아래와 같이 실행해 주었다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source .bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지 하면 awscli의 설치 과정이 끝났다.
아래 명령으로 설치가 완료되었는지 확인해 보았다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws --version
aws-cli/1.16.209 Python/3.6.8 Linux/4.15.0-1044-aws botocore/1.12.199
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;방금 설치한 awscli의 버전을 출력하는 것인데 잘 실행된다.
정상적으로 설치된 것을 알 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;ec2-instance에서-s3-접근을-위한-iam-설정하기&quot;&gt;EC2 instance에서 S3 접근을 위한 IAM 설정하기&lt;/h1&gt;
&lt;p&gt;위와 같이 awscli를 설치해 주고 나면 이제는 현재 사용 중인 EC2 instance에서 S3에 접근할 수 있도록 IAM 설정을 해 주어야 한다.
awscli를 설치했다고 해서 아무나 내 S3 버킷에 접근하면 안 되므로 당연히 필요한 절차다.
사실 이번 포스팅에서 가장 중요한 절차가 아닐까 생각한다.&lt;/p&gt;

&lt;p&gt;EC2 instance 위에서 오른쪽 버튼을 클릭하면 메뉴가 나오는데, 그 중에서 &lt;strong&gt;인스턴스 설정&lt;/strong&gt; → &lt;strong&gt;IAM 역할 연결/바꾸기&lt;/strong&gt;를 클릭한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=138xA2rtlmhUfFV7S-rZyzqikXUKXQZBP&quot; alt=&quot;EC2 인스턴스에 S3의 접근 권한을 주기 위해서는 IAM 역할을 부여해 주어야 한다.&quot; title=&quot;EC2 인스턴스에서 IAM 설정하는 메뉴&quot; /&gt;
    &lt;figcaption&gt;EC2 인스턴스에 S3의 접근 권한을 주기 위해서는 IAM 역할을 부여해 주어야 한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그러면 새 탭이 뜨면서 아래와 같은 IAM 역할 연결/바꾸기 페이지가 연결된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1JHv_96FsOUFPFILbfK5WaNh4NgB0i7Ha&quot; alt=&quot;EC2 인스턴스에 부여할 IAM 역할을 선택하는 탭이 뜬다.&quot; title=&quot;EC2 인스턴스에 연결할 IAM 역할 선택&quot; /&gt;
    &lt;figcaption&gt;EC2 인스턴스에 부여할 IAM 역할을 선택하는 탭이 뜬다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이 화면에서는 EC2 instance에 어떤 IAM 역할을 연결할지 선택할 수 있다.
만약 이전에 S3에 접근할 수 있는 IAM 역할을 만든 적이 있다면 그 IAM 역할을 선택하면 된다.&lt;/p&gt;

&lt;p&gt;사실 나는 wordpress 블로그를 만지면서 그런 IAM 역할을 만든 적이 있긴 하다.
지금은 wordpress도 안 쓰고 있고 따라서 자연히 그 때 만들어 둔 IAM 역할도 floating 상태이다.
어쨌든 오래되기도 했으니 이번에 새로 EC2 인스턴스에 연결할 IAM 역할을 만들었다.
파란색 글씨로 되어 있는 &lt;strong&gt;새 IAM 역할 생성&lt;/strong&gt;을 클릭한다.
그러면 이렇게 생긴 화면이 뜬다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1DU74w3DhI7-RPagIgCHIfwtnVGUQKyAs&quot; alt=&quot;새 IAM 역할 생성을 시작하는 페이지.&quot; title=&quot;IAM 역할 생성 페이지&quot; /&gt;
    &lt;figcaption&gt;새 IAM 역할 생성을 시작하는 페이지.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;AWS의 EC2 서비스 페이지에서 IAM 서비스 페이지로 이동되었다.
상단에 있는 &lt;strong&gt;역할 만들기&lt;/strong&gt;라는 눈에 띄는 파란색 버튼을 클릭한다.&lt;/p&gt;

&lt;p&gt;그러면 아래와 같은 역할 만들기 페이지가 나온다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1LFZQJiZSkNmcMjcJvDs-hLiIFUk2ZyU4&quot; alt=&quot;IAM 역할 만들기의 첫 번째 단계에서는 만들 IAM 역할을 어떤 유형의 개체에서, 어떤 서비스에서 이용할지 정해 주어야 한다.&quot; title=&quot;IAM 역할 만들기 첫 번째 단계: 개체, 서비스 선택&quot; /&gt;
    &lt;figcaption&gt;IAM 역할 만들기의 첫 번째 단계에서는 만들 IAM 역할을 어떤 유형의 개체에서, 어떤 서비스에서 이용할지 정해 주어야 한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기에서 지금은 EC2 instance에서 S3 버킷에 접근할 수 있는 권한을 주려는 것이므로
신뢰할 수 있는 유형의 개체 선택에서는 &lt;strong&gt;AWS 서비스&lt;/strong&gt;, 이 역할을 사용할 서비스 선택에서는 &lt;strong&gt;EC2&lt;/strong&gt;에 해당한다.
&lt;strong&gt;EC2&lt;/strong&gt;를 클릭한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1L_vx1yYxeDvLuLAcrCKXl1kusYsaDwHD&quot; alt=&quot;IAM 역할 만들기의 두 번째 단계에서는 해당 IAM 역할에서 어떤 권한을 줄 지 선택한다.&quot; title=&quot;IAM 역할 만들기 두 번째 단계: 연결 (선택 전)&quot; /&gt;
    &lt;figcaption&gt;IAM 역할 만들기의 두 번째 단계에서는 해당 IAM 역할에서 어떤 권한을 줄 지 선택한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 역할 만들기의 두 번째 페이지인데, 권한 정책 연결을 해 주어야 한다.
이미 정의된 많은 정책 중에서 하나를 선택해 주면 된다.
정책 필터에 ‘s3’라고 입력하면 s3와 관련된 권한 정책만 볼 수 있다.
&lt;strong&gt;‘AmazonS3FullAccess’의 체크박스&lt;/strong&gt;를 클릭하여 선택 상태로 만들어 준다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1yCu2sEl-qEkePknQn-3uAh-nVrtSxwRQ&quot; alt=&quot;지금은 S3의 접근 권한을 부여하는 것이 목적이므로 AmazonS3FullAccess에 체크한다.&quot; title=&quot;IAM 역할 만들기 두 번째 단계: 연결 (선택 후)&quot; /&gt;
    &lt;figcaption&gt;지금은 S3의 접근 권한을 부여하는 것이 목적이므로 AmazonS3FullAccess에 체크한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;지금은 S3에만 접근하면 되기 때문에 다른 정책은 필요가 없었지만, 여러 가지의 권한을 동시에 부여하는 것도 가능하다.
AmazonS3FullAccess의 체크를 유지한 채로 다른 정책을 찾아서 선택해 주면 된다.&lt;/p&gt;

&lt;p&gt;권한 정책의 선택이 완료되었으면 오른쪽 하단의 &lt;strong&gt;다음:태그&lt;/strong&gt; 버튼을 클릭한다.
이번에는 태그 추가(선택 사항) 페이지가 떴다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=18tXEoebfl0zmjEom_cZaN8cn63-ye0dv&quot; alt=&quot;IAM 권한의 태그를 추가할 수 있는 페이지가 나온다.&quot; title=&quot;IAM 역할 만들기 세 번째 단계: 태그&quot; /&gt;
    &lt;figcaption&gt;IAM 권한의 태그를 추가할 수 있는 페이지가 나온다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기서는 그냥 넘어가도 관계없지만, 나는 {Name: Jekyll}이라는 태그를 추가했다.
그리고 오른쪽 하단의 &lt;strong&gt;다음:검토&lt;/strong&gt; 버튼을 클릭한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1whcdUBcuKCubKiFTk1XxQPx9lSiC0oo3&quot; alt=&quot;마지막으로 IAM 역할의 이름을 설정하며 검토한 후 완료된다.&quot; title=&quot;IAM 역할 만들기 네 번째 단계: 검토&quot; /&gt;
    &lt;figcaption&gt;마지막으로 IAM 역할의 이름을 설정하며 검토한 후 완료된다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;역할 만들기 페이지의 마지막, 검토 단계이다.
역할 이름을 설정해 주어야 하는데, 이 이름을 Jekyll이라고 입력하였다.
그리고 나서 오른쪽 하단의 &lt;strong&gt;역할 만들기&lt;/strong&gt; 버튼을 클릭하면 된다.
이렇게 하면 성공적으로 S3에 접근할 수 있는 IAM 역할을 만든 것이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1kJlpEoLIqDw4iOyIomxxeCzXVczYdYgn&quot; alt=&quot;조금 전 추가한 IAM 역할이 추가된 모습을 확인할 수 있다.&quot; title=&quot;IAM 역할이 추가된 후&quot; /&gt;
    &lt;figcaption&gt;조금 전 추가한 IAM 역할이 추가된 모습을 확인할 수 있다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위와 같이 IAM 역할 리스트에 나온다.
이 탭에서 해야 할 일은 끝났으므로 탭을 닫아주었다.&lt;/p&gt;

&lt;p&gt;아까 &lt;strong&gt;새 IAM 역할 생성&lt;/strong&gt;을 클릭했던 탭으로 돌아왔다.
그 왼쪽에 있었던 새로고침 심볼을 클릭한 후, 현재 &lt;strong&gt;역할 없음&lt;/strong&gt;으로 선택되어 있는 콤보박스를 클릭하여 조금 전에 만들었던 &lt;strong&gt;Jekyll&lt;/strong&gt;을 선택한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1pcN8eMrAH1gPALtZS1dbZETAPf66TgvS&quot; alt=&quot;조금 전 추가한 IAM 역할을 선택해 준다.&quot; title=&quot;EC2 인스턴스에 IAM 역할을 부여하는 페이지&quot; /&gt;
    &lt;figcaption&gt;조금 전 추가한 IAM 역할을 선택해 준다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 나서 오른쪽 하단의 적용 버튼을 클릭하면 된다.
이렇게 하면 EC2 instance에서 S3에 접근할 수 있는 권한이 생긴다.&lt;/p&gt;

&lt;p&gt;그럼 이제 제대로 되었는지 간단한 명령을 통해 확인해 볼 시간이다.
아래 명령은 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt;라는 빈 텍스트 파일을 생성한 후, S3에 &lt;code class=&quot;highlighter-rouge&quot;&gt;chobolife-test&lt;/code&gt;라는 버킷을 만들고, &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt;를 업로드하는 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch test.txt
$ aws s3 mb s3://chobolife-test
make_bucket: chobolife-test
$ aws s3 cp test.txt s3://chobolife-test
upload: ./test.txt to s3://chobolife-test/test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 mb&lt;/code&gt; 명령에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;make_bucket&lt;/code&gt;라는 메시지가, &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 cp&lt;/code&gt; 명령에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;upload&lt;/code&gt;라는 메시지가 출력되었다.
제대로 업로드가 된 것 같아 보인다.
웹브라우저에서 AWS 콘솔에 들어가서 확인해 보았다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1qIxLXq613K5eq4n1R7u57Albu2_4PVwJ&quot; alt=&quot;S3 버킷 생성과 테스트 파일 업로드가 잘 된 것을 알 수 있다.&quot; title=&quot;Ubuntu에서 S3 버킷을 만들고 테스트 파일을 올린 모습&quot; /&gt;
    &lt;figcaption&gt;S3 버킷 생성과 테스트 파일 업로드가 잘 된 것을 알 수 있다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;chobolife-test&lt;/code&gt;라는 버킷 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt;라는 0바이트의 파일이 잘 업로드되었다.
그런데 너 왜… 버지니아에 있니?
아마 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 mb&lt;/code&gt; 명령으로 버킷을 생성하면서 리전을 지정하는 방법이 있을 것 같은데, 지정하지 않으면 임의의 리전에 생성되는 것 같다.
어쨌든 이렇게 EC2 instance에서 ubuntu 터미널에서 S3에 접근할 수 있다는 점은 확인하였다.&lt;/p&gt;

&lt;h1 id=&quot;jekyll-폴더를-s3에-올리기&quot;&gt;Jekyll 폴더를 S3에 올리기&lt;/h1&gt;
&lt;p&gt;이제 마지막 단계에 왔다.
터미널에서 S3에 접근할 수 있는 package도 설치했고, EC2 instance에서 S3에 접근할 수 있는 권한도 얻었다.
이제는 Jekyll에서 만든 사이트를 S3에 올리는 일만 남았다.&lt;/p&gt;

&lt;p&gt;일단 먼저 S3 버킷을 생성했다.
아까처럼 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 mb&lt;/code&gt; 명령으로 만들 수도 있지만, 나는 아래와 같이 AWS 콘솔에 들어가서 만들었다.&lt;/p&gt;

&lt;p&gt;S3 서비스 페이지로 들어가서 &lt;strong&gt;버킷 만들기&lt;/strong&gt; 버튼을 클릭하면 이렇게 생긴 상자가 뜬다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1dPGmz5vaaqfibSJcFHDhSSCNOfkn46yd&quot; alt=&quot;AWS 콘솔에서 S3 서비스 페이지에 들어온 후 버킷을 만드는 페이지에 들어왔다.&quot; title=&quot;S3 버킷 만들기: 이름 및 리전&quot; /&gt;
    &lt;figcaption&gt;AWS 콘솔에서 S3 서비스 페이지에 들어온 후 버킷을 만드는 페이지에 들어왔다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기에서 &lt;strong&gt;버킷 이름&lt;/strong&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;chobolife-draft&lt;/code&gt;라고 입력하였다.
그리고 &lt;strong&gt;다음&lt;/strong&gt; 버튼을 클릭한다.
그러면 옵션 구성이라는 화면으로 넘어가는데 여기에서는 특별히 설정할 것이 없으므로 아무 작업도 없이 바로 &lt;strong&gt;다음&lt;/strong&gt; 버튼을 클릭했다.
그리고 나면 권한 설정이라는 화면이 나온다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1TED6sRbptySD313YlxQPntofWYrI0g2m&quot; alt=&quot;정적 웹 호스팅을 위한 S3 버킷은 퍼블릭 액세스를 허용해 주어야 한다. 퍼블릭 액세스 차단을 설정하는 체크박스를 해제해 준다.&quot; title=&quot;S3 버킷 만들기: 권한 설정&quot; /&gt;
    &lt;figcaption&gt;정적 웹 호스팅을 위한 S3 버킷은 퍼블릭 액세스를 허용해 주어야 한다. 퍼블릭 액세스 차단을 설정하는 체크박스를 해제해 준다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기에서는 현재 버킷의 목적이 정적 웹 호스팅을 하기 위한 것이므로 모든 퍼블릭 액세스 차단을 풀어 주어야 한다.
체크박스를 해제한 후 &lt;strong&gt;다음&lt;/strong&gt; 버튼을 클릭한다.
그리고 나면 &lt;code class=&quot;highlighter-rouge&quot;&gt;chobolife-draft&lt;/code&gt;라는 이름의 버킷 생성이 완료되었다.&lt;/p&gt;

&lt;p&gt;따로 캡쳐하지는 않았지만, 정적 웹 호스팅을 위한 설정을 해 주어야 한다.
S3 버킷의 &lt;strong&gt;속성&lt;/strong&gt; 페이지에 들어가서 &lt;strong&gt;정적 웹 사이트 호스팅&lt;/strong&gt;을 설정해 주었다.&lt;/p&gt;

&lt;p&gt;그리고 나서 나는 당당하게 Jekyll의 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리에서 아래와 같이 실행했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 cp * s3://chobolife-draft
Unknown options: assets,blog,feed.xml,index.html,s3://chobolife-draft
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어라? 이상하다.
아까 분명히 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 cp&lt;/code&gt; 명령으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt; 파일을 올렸는데 왜 안되지?
이것은 다행히 구글링을 통해 금방 해결하였다.&lt;/p&gt;

&lt;p&gt;더불어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 폴더를 제외한 모든 폴더와 파일을 올리는 방법도 찾았고, &lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/read-access-objects-s3-bucket/&quot;&gt;Amazon docs&lt;/a&gt;에서 S3에 업로드하면서 퍼블릭 권한을 설정하는 방법까지 찾았다.
아래의 명령으로 하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws s3 cp ~/chobolife/_site s3://chobolife-draft --recursive --exclude &quot;.git/*&quot; --acl public-read
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;을 제외한 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리 아래에 있는 모든 파일이 업로드되며 아래와 같이 뜬다.
아까 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt; 파일 하나만 올렸을 때와 동일한 로그가 각 파일마다 뜨는 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;upload: _site/blog/2019/08/01/jekyll-draft/index.html to s3://chobolife-draft/blog/2019/08/01/jekyll-draft/index.html
upload: _site/blog/2019/08/03/ec2-s3-authority/index.html to s3://chobolife-draft/blog/2019/08/03/ec2-s3-authority/index.html
upload: _site/about/index.html to s3://chobolife-draft/about/index.html
upload: _site/assets/minima-social-icons.svg to s3://chobolife-draft/assets/minima-social-icons.svg
upload: _site/index.html to s3://chobolife-draft/index.html
upload: _site/feed.xml to s3://chobolife-draft/feed.xml
upload: _site/blog/2019/07/29/google-drive-image/index.html to s3://chobolife-draft/blog/2019/07/29/google-drive-image/index.html
upload: _site/blog/2019/07/31/jekyll-image/index.html to s3://chobolife-draft/blog/2019/07/31/jekyll-image/index.html
upload: _site/404/index.html to s3://chobolife-draft/404/index.html
upload: _site/blog/2019/07/26/welcome-to-jekyll/index.html to s3://chobolife-draft/blog/2019/07/26/welcome-to-jekyll/index.html
upload: _site/blog/2019/07/28/jekyll-github/index.html to s3://chobolife-draft/blog/2019/07/28/jekyll-github/index.html
upload: _site/blog/2019/07/27/start-jekyll-2/index.html to s3://chobolife-draft/blog/2019/07/27/start-jekyll-2/index.html
upload: _site/blog/2019/07/26/start-jekyll-1/index.html to s3://chobolife-draft/blog/2019/07/26/start-jekyll-1/index.html
upload: _site/assets/main.css to s3://chobolife-draft/assets/main.css
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 내가 처음에 의도했던 모든 작업은 끝이 났다.
Jekyll의 초안을 웹브라우저에서 확인해 보고 싶었는데, 이를 S3를 통해 실현하였다.
이제 작성하던 초안이 웹에 공개되지 않아도 되고, 사소한 수정사항에도 git의 로그가 더럽혀지는 것을 막을 수 있게 되었다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">Jekyll 블로그의 초안을 AWS S3에 업로드 이전 포스팅(Jekyll 초안 관리에 대한 고민)에서 했던 고민의 결론은 ‘Jekyll 블로그의 초안을 github page에 commit하기 전에 AWS S3에 업로드해서 나만 먼저 확인해보겠다’는 것이었다. 그리고 그것을 위해 약간의 삽질을 했지만 결국 AWS CLI를 이용하여 ubuntu에서 S3에 업로드하는 방법을 찾았다. 이번 포스팅에서는 그 방법을 정리해 두려고 한다.</summary></entry><entry><title type="html">Jekyll 초안 관리에 대한 고민</title><link href="/blog/2019/08/01/jekyll-draft/" rel="alternate" type="text/html" title="Jekyll 초안 관리에 대한 고민" /><published>2019-08-01T22:35:00+09:00</published><updated>2019-08-01T22:35:00+09:00</updated><id>/blog/2019/08/01/jekyll-draft</id><content type="html" xml:base="/blog/2019/08/01/jekyll-draft/">&lt;h1 id=&quot;문제의식&quot;&gt;문제의식&lt;/h1&gt;
&lt;p&gt;Jekyll을 이용한 블로깅은 그 자체로 재미가 있었다.
게다가 포스팅이 쉽기까지 했다.
(일단 Jekyll을 설치할 때까지는 약간 험난했지만 말이다.)
그런데 쓰다보니 한 가지 불편한 점이 있었다.
바로 초안을 관리하는 것이었다.&lt;/p&gt;

&lt;p&gt;나는 사진이든 동영상이든 트위터같은 짧은 글이든 아니면 엄청나게 긴 길이든, 어떤 형태로든지 인터넷에 자료를 올리는 것은 publish, 즉 출판이라는 생각을 갖고 있다.
그래서 가급적 완성된 포스트만 공개하고 싶고, 한 번 publish한 이후로는 내용에 큰 오류가 있지 않은 이상 수정도 하고 싶지 않다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=139mSbzwwbNY2J2pFEXV5ImB4E_UnKj9f&quot; alt=&quot;인터넷에 정보를 '공개'하는 것은 '출판'과 유사하다.&quot; title=&quot;출판물&quot; /&gt;
    &lt;figcaption&gt;인터넷에 정보를 '공개'하는 것은 '출판'과 유사하다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;초안은 아직 완성되지도 않았을 뿐 아니라, 초안 작성 당시에는 실제로 이걸 포스팅을 할 것인지, 말 것인지조차도 결정하지 못한 것이 많을 것이라고 예상한다.
그래서 나는 &lt;strong&gt;초안이 다른 포스팅과 함께 공개되지 않으면서도 나만 확인할 수 있는 방법&lt;/strong&gt;을 찾기 시작했다.&lt;/p&gt;

&lt;h1 id=&quot;jekyll의-초안-작성-방법&quot;&gt;Jekyll의 초안 작성 방법&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://jekyllrb-ko.github.io/docs/drafts/&quot;&gt;Jekyll 홈페이지&lt;/a&gt;에는 초안을 이렇게 관리하면 된다고 나와 있다.
작성하고 있는 초안은 &lt;code class=&quot;highlighter-rouge&quot;&gt;_drafts&lt;/code&gt; 디렉토리에 넣으면 되고 그 파일명은 연, 월, 일에 대한 정보 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;title.md&lt;/code&gt;와 같은 식으로 지정하면 된다.
이렇게 하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build --drafts&lt;/code&gt;를 실행하면 초안이 빌드되고 가장 최신 포스트로 표시된다고 한다.
내가 해보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;drafts&lt;/code&gt; 대신 s를 빼고 &lt;code class=&quot;highlighter-rouge&quot;&gt;draft&lt;/code&gt;까지만 쳐도 문제가 없는 것 같다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build --draft&lt;/code&gt;를 실행해도 동일하게 초안까지 포함해서 빌드된다.&lt;/p&gt;

&lt;p&gt;AWS EC2에 ssh로 접속해서 Jekylling을 하는 나에게 Jekyll 문서에서 이야기하는 위 방법은 도움이 되긴 하지만 또 어떤 면에서는 도움이 별로 되지 못한다.
현재까지 작성한 초안을 빌드해서 웹브라우저에서 확인할 수 있는 것은 좋다.
하지만 문제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build --draft&lt;/code&gt;를 실행하게 되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리에 초안을 포함한 사이트가 발행되므로 이걸 확인하려면 Github Pages에 commit해야 하며, 그렇게 되면 &lt;strong&gt;초안이 블로그에 공개되어 버린다는 것이다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;보통 다른 사람들은 windows, ubuntu 등 OS에 관계없이 로컬에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;를 실행해서 빌드하고 웹브라우저로 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000/&lt;/code&gt;에 접속하여 확인하는 것 같다.
그렇게 하면 commit하기 전에 확인 후 수정이 필요한 부분을 변경할 수 있다.
하지만 나는 cygwin에서 EC2 instance에 ssh로 접속하여 Jekylling을 하고 있으므로 다른 방법을 찾아야 했다.&lt;/p&gt;

&lt;p&gt;물론 나도 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;를 실행하여 확인할 수 있는 방법은 있다.
EC2에 &lt;strong&gt;vnc&lt;/strong&gt;로 접속하면 가능하다.
그런데 나는 그 방법은 쓰고 싶지 않았다.
왜냐하면 우선 EC2에 vnc server를 설치해야 하는데 그 용량이 꽤 크다고 알고 있다.
뿐만 아니라 현재는 free tier에서 무료로 사용이 가능한 intsance인 t2.micro를 이용하고 있는데 다른 t2.micro가 필요하거나 free tier가 끝나는 시점이 되면 t2.nano로 옮기게 될 수도 있다.
그러면 vnc server 구동은 시스템에 부담이 되어 사용하기 어려울 것이다.
또 한 가지 문제는 너무 복잡할 것이라는 점이다.
Cygwin으로 접속해서 vim으로 내용을 입력하고 포스팅하는 것이 지금까지는 굉장히 가벼운 작업이었는데, 초안을 확인하겠다고 옆에 다른 vnc viewer 프로그램을 띄워놓고 그 안에 Firefox 같은 웹브라우저를 실행하는 것은 생각만 해도 번거롭고 복잡한 일이었다.&lt;/p&gt;

&lt;h1 id=&quot;고민-끝에-s3&quot;&gt;고민 끝에 S3&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리에 git repository가 만들어져 있으므로 버전 관리가 되고 있는데 혹시 git의 branch를 이용한 방법이 없을까 하는 생각도 해 보았다.
그런데 branch를 활용할 수 있는 뾰족한 방법이 떠오르지 않았다.
그 외에도 여러 가지 고민을 더 해 보았는데 괜찮은 방법이 없는 것 같았다.&lt;/p&gt;

&lt;p&gt;그러다가 생각한 방법은 이것이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;어차피 작성하던 초안이 웹브라우저에 어떻게 표시되는지 확인하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build --drafts&lt;/code&gt;를 해서 발행을 해야 한다. 그렇다면 그것을 블로그가 공개되는 Github Pages 말고 &lt;strong&gt;나만 아는 곳&lt;/strong&gt;에 올려두고 확인하면 되지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;생각할수록 괜찮은 방법인 것 같았다.
포스팅을 완성하기 전의 작성 및 수정 단계에서는 Github Pages에만 올리지 않으면 내 블로그를 통해 공개되지 않는 것이고, 그 때에 바로 그 &lt;strong&gt;나만 아는 곳&lt;/strong&gt;에 올려서 확인해보는 건 아무 문제가 없으니까.
그렇게 확인하면서 수정하다가 포스트가 완성되고 나면 md 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;_drafts&lt;/code&gt; 디렉토리에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 디렉토리로 옮기면서 Github Pages에도 commit하면 될 것 같다.
그런 절차를 생각하고 보니 초안을 처음부터 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;_drafts&lt;/code&gt; 디렉토리에 넣을 것 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 디렉토리에서 시작을 해도 될 것 같기는 하다.
하지만 우선은 정석대로 초안은 &lt;code class=&quot;highlighter-rouge&quot;&gt;_drafts&lt;/code&gt; 디렉토리에서만 작성할 생각이다.&lt;/p&gt;

&lt;p&gt;그 &lt;strong&gt;나만 아는 곳&lt;/strong&gt;은 AWS S3에 구축하려고 한다.
AWS S3가 편할 것 같기도 하고… 사실 다른 마땅한 곳이 생각이 안 난다.
정적 웹 호스팅을 제공하는 곳은 여러 군데 있기는 한데 거의 다 생소한 곳들이라서…
처음에 Jekyll을 시작하면서 정적 웹 호스팅을 어디에 할지를 놓고 &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;와 &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;AWS S3&lt;/a&gt; 사이에서 고민했었다.
(&lt;a href=&quot;/blog/2019/07/27/start-jekyll-2/&quot;&gt;나의 Jekyll 여행기 (2)&lt;/a&gt; 참고)
둘을 놓고 고민하다가 S3보다 간단할 것 같아서 github을 쓴 것이었는데…
이렇게 둘 다 쓰게 될 줄이야.&lt;/p&gt;

&lt;p&gt;그렇다면 이제 앞으로 해야 할 일은 ubuntu에 AWS CLI를 설치하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에 있는 파일들을 S3 버킷에 업로드하는 것인데, 한 번도 해 보지 않은 일이라서 약간 험난한 과정이 예상된다.
이 방법을 시도해 보고 다음 포스팅에 업로드할 예정이다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">문제의식 Jekyll을 이용한 블로깅은 그 자체로 재미가 있었다. 게다가 포스팅이 쉽기까지 했다. (일단 Jekyll을 설치할 때까지는 약간 험난했지만 말이다.) 그런데 쓰다보니 한 가지 불편한 점이 있었다. 바로 초안을 관리하는 것이었다.</summary></entry><entry><title type="html">Jekyll post에 이미지 첨부하기</title><link href="/blog/2019/07/31/jekyll-image/" rel="alternate" type="text/html" title="Jekyll post에 이미지 첨부하기" /><published>2019-07-31T11:03:00+09:00</published><updated>2019-07-31T11:03:00+09:00</updated><id>/blog/2019/07/31/jekyll-image</id><content type="html" xml:base="/blog/2019/07/31/jekyll-image/">&lt;p&gt;&lt;a href=&quot;/blog/2019/07/29/google-drive-image/&quot;&gt;이전 포스팅 (Google drive에 공개 이미지 올리기)&lt;/a&gt;에서 구글 드라이브에 이미지 파일을 올리고 공개하는 방법을 소개했다.
이번 포스팅은 그렇게 올린 이미지 파일을 Jekyll에서 웹페이지에 포함시키는 방법에 대한 포스팅이다.&lt;/p&gt;

&lt;h1 id=&quot;이미지를-표현하는-markdown-기본-문법&quot;&gt;이미지를 표현하는 markdown 기본 문법&lt;/h1&gt;
&lt;p&gt;우선 &lt;a href=&quot;https://jekyllrb-ko.github.io/docs/posts/#이미지와-자원-삽입하기&quot;&gt;Jekyll 공식 문서&lt;/a&gt;에 나와 있는 이미지 첨부 방법은 아래와 같다.
기본적인 syntax는 간단하다.&lt;/p&gt;
&lt;div class=&quot;language-md highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;alt-text-message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;image-link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 이미지를 첨부할 수 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;image-link&lt;/code&gt;는 이미지의 주소이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;alt-text-message&lt;/code&gt;는 대체 텍스트, 즉 이미지가 정상적으로 표시되지 않을 때 대신해서 나타나는 텍스트이다.&lt;/p&gt;

&lt;p&gt;예를 들어서 이전 포스팅에서 업로드했던 Grand Canyon의 이미지를 첨부하려면 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;language-md highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Grand Canyon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 예시 코드에서 이미지의 주소는 이전 포스팅에 소개한 방법으로 얻어냈고, 대체 텍스트는 ‘Grand Canyon’으로 입력한 것이다.
그리고 이 markdown을 문서에 삽입하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;를 실행하면 그 부분에 아래와 같은 html 코드가 생긴다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Grand Canyon&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아주 간단하고 편한 방법이다.
나는 처음에 이 방법만으로 매우 만족했으므로 이 방법을 계속 쓰려고 생각했다.&lt;/p&gt;

&lt;h1 id=&quot;쓰다보니-보이는-문제&quot;&gt;쓰다보니 보이는 문제&lt;/h1&gt;
&lt;p&gt;하지만 막상 이렇게 이미지를 첨부해보니 한 가지 문제가 있었다.
이미지의 캡션이 없다는 것이다.
검색을 통해 알아보니 Jekyll 자체적으로는 이미지의 캡션을 달아주지 않는댄다.
즉, markdown 문법만 가지고는 캡션을 달 방법이 없다고 한다.&lt;/p&gt;

&lt;p&gt;캡션은 있으면 좋지만 없어도 큰 문제는 없으므로…
나는 뭐 그냥 이대로 캡션 없어도 된다고 생각하고 쓰려고 했다.&lt;/p&gt;

&lt;p&gt;그런데 이미지 여러 개를 첨부하고 포스팅도 여러 개 쓰다보니 불편한 점이 하나 더 있었다.
그것은 바로 이미지 주소 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 을 &lt;code class=&quot;highlighter-rouge&quot;&gt;uc&lt;/code&gt;로 바꾸어 주어야 한다는 것이다.
이미지 여러 개를 첨부하고, 포스팅도 여러 개 쓰다보니 이걸 자꾸 잊어버리게 되었다.
빠뜨렸더라도 확인하고 금방 고칠 수 있으니 사소한 문제이긴 하지만 분명히 이걸 해결할 수 있는 간단한 방법이 있을 것 같았다.&lt;/p&gt;

&lt;p&gt;이미지에 캡션을 달고 싶다는 생각, 그리고 이미지의 주소를 쉽게 변환하고 싶다는 욕심.
꼭 이 두 가지를 해결해야겠다는 생각으로 찾아낸 것은 아니었다.
그것과는 상관없이 그냥 Jekyll 공식 문서나 Jekyll 관련한 블로그의 웹서핑을 하면서 알게 된 것이 있다.
바로 &lt;strong&gt;조각파일&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h1 id=&quot;조각파일로-이미지-첨부를-간단하게&quot;&gt;조각파일로 이미지 첨부를 간단하게&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://jekyllrb-ko.github.io/docs/includes/&quot;&gt;Jekyll 공식 문서&lt;/a&gt;에 나온 조각파일의 설명에 따르면 조각파일이란 &lt;strong&gt;반복되는 코드를 미리 정의하고 markdown에서 이를 함수 호출하듯이 이용하는 방법&lt;/strong&gt;인 것 같다.
위 문서를 보면 조각파일을 이용해서 이미지 첨부를 쉽게 하는 방법으로 아래와 같은 예제가 소개되어 있다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;figure&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ include.url }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ include.file }}&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;max-width: {{ include.max-width }};&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ include.alt }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/span&gt;{{ include.caption }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figcaption&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figure&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예제를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;max-width&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;caption&lt;/code&gt;의 다섯 개의 파라미터를 넘겨주게 되어 있다.
코드를 그대로 써도 무방하지만 나는 이 방법을 참고해서 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt; 디렉토리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;i-g.html&lt;/code&gt; 파일을 만들었다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;figure&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://drive.google.com/uc?id={{ include.id }}&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ include.alt }}&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;title=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ include.title }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/span&gt;{{ include.alt }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figcaption&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figure&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예제 파일에서 내가 수정한 사항들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가장 먼저 이미지의 주소 부분을 수정했다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i-g.html&lt;/code&gt; 조각파일 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://drive.google.com/uc?id=&lt;/code&gt; 부분까지 hard coding 으로 박아넣고 그 뒷 부분만 파라미터화하였다.&lt;/li&gt;
      &lt;li&gt;이렇게 하면 내가 처음에 의도한 대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;uc&lt;/code&gt;를 바꾸어 주는 작업을 대체할 수 있을 뿐 아니라 중복되는 코드를 아예 조각파일 안으로 넣어버릴 수 있어서 깔끔해진다.&lt;/li&gt;
      &lt;li&gt;Markdown에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;i-g.html&lt;/code&gt;을 include 시킬 때는 구글 드라이브에서 따온 이미지 주소의 뒷부분인 id 속성만 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; 파라미터의 값으로 넣어 주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그리고 나는 이미지에 링크를 걸 필요가 없으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 태그와 &lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt; 파라미터를 삭제했다.
(만약에 필요한 일이 생기면 이 조각파일을 쓰지 못할 것 같은데… 그건 그 때 다시 생각하기로 하자.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max-width&lt;/code&gt; 속성도 굳이 필요하지 않을 것 같아서 삭제했다.&lt;/li&gt;
  &lt;li&gt;이미지의 캡션 따로, 대체 텍스트 따로 써 주기 귀찮을 것 같았다. 그래서 캡션과 대체 텍스트가 동일하게 표시되게 하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;figcaption&lt;/code&gt; 태그 안에 있었던 &lt;code class=&quot;highlighter-rouge&quot;&gt;caption&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt;를 넣어주었다.&lt;/li&gt;
  &lt;li&gt;대신 이미지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 속성을 추가하였다. Title은 대체 텍스트나 캡션과는 다르게 간단한 키워드 중심으로 이미지의 제목을 지정해 주기 위해 추가했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;i-g.html&lt;/code&gt; 파일을 작성했다면 이미지 파일을 첨부하려는 곳에는 아래와 같이 입력한다.&lt;/p&gt;

&lt;div class=&quot;language-md highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% include i-g.html id=&quot;1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot; alt=&quot;하늘과 Grand Canyon이 만나는 드넓은 곳에서 앞으로 열릴 탁 트인 미래를 상상하자.&quot; title=&quot;시원하게 열릴 내 미래&quot; %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;조금 길어서 복잡해 보이지만 사실 내용은 간단하다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;i-g.html&lt;/code&gt; 조각파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;한다는 것이고 그것을 위해 넘겨주는 파라미터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 이 세 개가 끝이다.&lt;/p&gt;

&lt;p&gt;어쨌든 위와 같은 markdown을 추가하면 생성되는 html 문서에는 아래와 같은 html 코드가 생긴다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;figure&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;하늘과 Grand Canyon이 만나는 드넓은 곳에서 앞으로 열릴 탁 트인 미래를 상상하자.&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;title=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;시원하게 열릴 내 미래&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/span&gt;하늘과 Grand Canyon이 만나는 드넓은 곳에서 앞으로 열릴 탁 트인 미래를 상상하자.&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figcaption&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figure&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제 웹페이지에 표시되는 모습은 아래와 같다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot; alt=&quot;하늘과 Grand Canyon이 만나는 드넓은 곳에서 앞으로 열릴 탁 트인 미래를 상상하자.&quot; title=&quot;시원하게 열릴 내 미래&quot; /&gt;
    &lt;figcaption&gt;하늘과 Grand Canyon이 만나는 드넓은 곳에서 앞으로 열릴 탁 트인 미래를 상상하자.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 위에 마우스 커서를 놓고 있으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 속성으로 지정한 문구가 툴팁으로 뜬다.
이미지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 속성을 추가한 것은 SEO에 도움이 될까 싶어서였지 이 효과를 의도한 것은 아니다.
하지만 어쨌든 이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 속성이 뜨는 것도 괜찮은 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;알아두어야-할-점&quot;&gt;알아두어야 할 점&lt;/h1&gt;
&lt;p&gt;조각파일에 대한 Jekyll 문서를 보고 일단 필요한 것은 했는데…
문서를 계속 읽다보면 아래와 같은 언급이 나온다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;하지만, 조각파일을 너무 많이 사용하는 것은, 사이트의 빌드 시간을 느리게 &lt;del&gt;만드므로&lt;/del&gt;(만들므로), 가급적 피해야 합니다. 예를 들어, 이미지를 삽입할 때마다 매번 조각파일을 사용하는 것은 좋지 않습니다. (위의 예시는 특별취급해야하는 일부 이미지에 사용할만한 기법입니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어.. 음… 그.. 그,그래. 알겠어.
알겠고 충고는 고마운데 나는 일단 이대로 해볼게.
(= 나는 이미지 첨부할 때마다 조각파일 사용하겠다는 얘기)&lt;/p&gt;

&lt;p&gt;이 방법이 주는 편리함 때문에 포기하긴 어려울 것 같다.
빌드타임이 많이 느려진다면 그건 그 때 또 좋은 방법이 없을지 생각해 봐야겠다.&lt;/p&gt;

&lt;p&gt;P.S.
실제 내가 작성한 조각파일에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;img&lt;/code&gt; 태그 안에 줄바꿈을 넣지 않았다.
이 포스팅을 작성하면서 코드가 좌우로 너무 길어져서 가독성을 해치는 것을 방지하기 위해 줄바꿈을 추가한 것이다.
그래서 위의 code block에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; 속성별로 한 행씩 차지하고 있다.
하지만 이 포스팅의 소스를 확인하면 실제로 줄바꿈이 들어가 있지 않음을 알 수 있다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">이전 포스팅 (Google drive에 공개 이미지 올리기)에서 구글 드라이브에 이미지 파일을 올리고 공개하는 방법을 소개했다. 이번 포스팅은 그렇게 올린 이미지 파일을 Jekyll에서 웹페이지에 포함시키는 방법에 대한 포스팅이다.</summary></entry><entry><title type="html">Google drive에 공개 이미지 올리기</title><link href="/blog/2019/07/29/google-drive-image/" rel="alternate" type="text/html" title="Google drive에 공개 이미지 올리기" /><published>2019-07-29T16:45:00+09:00</published><updated>2019-07-29T16:45:00+09:00</updated><id>/blog/2019/07/29/google-drive-image</id><content type="html" xml:base="/blog/2019/07/29/google-drive-image/">&lt;p&gt;Jekyll에서 이미지를 올리는 방법에 대해서 찾아보았고, 코드조각이라는 것을 이용하여 나름의 방법을 구축했다.
그 방법을 소개하려고 하는데 그에 앞서 우선 이번 포스팅에서는 Google drive에 이미지 파일을 올리고 웹에 공개하는 방법까지만 작성했다.
그렇게 올린 이미지 파일을 Jekyll post에 표시하는 방법은 다음 포스팅에서 다룰 예정이다.&lt;/p&gt;

&lt;h1 id=&quot;네이버와-워드프레스에서-이미지-관리-방법의-차이&quot;&gt;네이버와 워드프레스에서 이미지 관리 방법의 차이&lt;/h1&gt;
&lt;p&gt;일단 먼저 생각해 봐야 할 점은 Jekyll에서는 포털사이트의 블로그(예를 들면 네이버 블로그)와 유사한 방법으로 이미지를 다룰 수 없다는 점이다.
굳이 따지자면 오히려 워드프레스의 이미지 관리 방법과 유사하다. 뒤에 얘기하겠지만 그렇다고 같지는 않다.
어쨌든 많이 쓰이는 블로깅 툴이 네이버 블로그와 워드프레스이므로 일단 그 둘의 이미지 관리 방법이 어떻게 다른지부터 생각해 보자.&lt;/p&gt;

&lt;p&gt;네이버 블로그에서는 포스팅을 하면서 이미지를 첨부하게 되어 있고, 그렇게 하면 포스팅별로 이미지가 관리된다.
설치형 워드프레스에서는 미디어 라이브러리에 이미지를 올리고 나서 그 이미지를 포스팅할 때 갖다 쓰게 된다.
이것만 보면 별 차이가 없어 보이겠지만
하나의 이미지 파일을 여러 포스팅에서 쓰게 되는 경우를 생각해 보면 얘기가 달라진다.&lt;/p&gt;

&lt;p&gt;첫 번째 경우 (네이버 블로그) 같은 경우에는 분명히 똑같은 이미지이지만 포스팅마다 따로 첨부가 된다.
포스트 2개에 같은 이미지 파일을 올리는 경우가 있다면
당연히 서버에도 두 개의 파일이 존재하고, 사용자의 브라우저에도 두 개가 캐싱된다.
서버 저장공간도, 네트워크 리소스도, 사용자의 캐시 메모리도 모두 2배로 필요하다.
만약에 같은 이미지를 포함하는 포스트 3개, 4개 등등으로 더 많아진다면 계속 필요한 자원이 증가한다.&lt;/p&gt;

&lt;p&gt;반대로 두 번째 경우 (설치형 워드프레스)에서는 서버에 말 그대로 미디어 라이브러리가 있는 것이다.
프로그램을 짜본 적이 있다면 library라는 말의 의미를 알 것이라고 생각한다.
한 번이라도 Hello World를 출력해 보았다면 이미 library를 사용해 본 것이다.
어쨌든, 워드프레스에서 미디어 라이브러리에는 라이브러리대로 이미지 파일을 올리고
포스팅에서는 그 라이브러리에 있는 파일을 보여주기만 할 뿐이다.
이 때는 서버에 단 하나의 파일만 존재한다.
사용자도 그 이미지가 캐싱되어 있다면, 즉 그 이미지 파일을 포함하는 포스팅을 하나 본 적이 있다면 다른 포스트에서는 이미지를 다시 다운로드하지 않는다.
네트워크 리소스도 절약되고 로딩 속도도 빨라진다.&lt;/p&gt;

&lt;p&gt;이렇게만 보면 무조건 두 번째 경우처럼 관리하는 것이 좋을지도 모른다.
하지만 두 번째 경우보다 첫 번째 경우가 직관적이다.
첫 번째 경우는 이미지가 포스트에 종속되기 때문에 포스트를 관리하는 것이 곧 이미지를 관리하는 것이다.
즉 포스트를 삭제하면 이미지도 같이 삭제되며 다른 신경을 쓸 필요가 없다.&lt;/p&gt;

&lt;p&gt;그런데 두 번째 경우에서는 이미지는 포스트에 종속되지 않는다.
이미지와 포스트는 독립적으로 존재한다.
그래서 포스트를 삭제해도 이미지는 삭제되지 않는다.
당연한 얘기지만 삭제해서도 안 된다. 그 이미지를 포함하는 모든 포스트가 삭제되었다는 보장이 없으니까.
그 이미지를 포함하는 포스트가 남아 있지 않다고 하더라도 나중에 다른 포스트에서 그 이미지를 띄울 수도 있는 것이기 때문에 미디어 라이브러리가 스스로 이미지를 지울 수는 없다.&lt;/p&gt;

&lt;h1 id=&quot;그렇다면-jekyll은&quot;&gt;그렇다면 Jekyll은?&lt;/h1&gt;
&lt;p&gt;Jekyll에서는 이미지가 포스트에 종속되지 않기 때문에 일단 네이버 블로그와는 방법이 다르다.
그렇다고 해서 워드프레스에서의 방법과 정확히 같은 것은 또 아니다.
Jekyll에서는 워드프레스의 미디어 라이브러리에 해당하는 것이 없다.
즉 미디어 라이브러리가 필요하다면 본인이 구축해야 하며, 필요하지 않다면 구축하지 않아도 된다.
어쨌든 Jekyll에서는 먼저 이미지 파일을 &lt;strong&gt;어떤 방법으로든&lt;/strong&gt; 웹에 업로드한 후 포스트를 작성할 때는 그 이미지 파일의 주소로 이미지를 띄워주면 된다.&lt;/p&gt;

&lt;p&gt;이미지를 웹에 업로드하는 방법은 무궁무진하다.
Jekyll 폴더 내에 이미지를 넣고 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;으로 웹페이지를 올리듯이 &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;에 업로드하는 방법도 있고 &lt;a href=&quot;https://www.dropbox.com/&quot;&gt;Dropbox&lt;/a&gt;, &lt;a href=&quot;https://www.google.com/drive/&quot;&gt;Google Drive&lt;/a&gt;, &lt;a href=&quot;https://aws.amazon.com/ko/s3/&quot;&gt;AWS S3&lt;/a&gt; 등의 서비스를 이용할 수도 있다.
이 중에서 나는 구글 드라이브를 선택했다.&lt;/p&gt;

&lt;p&gt;구글 드라이브를 선택한 이유는 기본적으로 트래픽이 무제한일 뿐 아니라 인증된 기관의 계정에서는 저장 공간도 무제한이기 때문이다.
github, dropbox, AWS S3 모두 저장 공간 또는 발생된 트래픽에 따라 요금이 부과된다.
물론 일정한 수준까지는 부과되지 않으며 보통의 개인용 블로그에서는 그런 수준을 넘지 않을 가능성이 매우 높다.
하지만 어떤 이유로 인하여 옮겨야 한다면 굉장히 번거로울 것 같았다.
그래서 그냥 처음부터 구글 드라이브에 이미지를 올리고 거기서 가져오는 게 나을 거라고 생각했다.
물론 이렇게 하려면 약간 귀찮은 작업이 필요하다.&lt;/p&gt;

&lt;h1 id=&quot;google-drive에서-폴더-공개를-위한-설정&quot;&gt;Google drive에서 폴더 공개를 위한 설정&lt;/h1&gt;
&lt;p&gt;우선 구글 드라이브에 로그인하고 이미지 관리를 위한 폴더를 생성하였다.
나는 블로그 이름과 같은 chobolife라는 폴더를 만들고 그 아래에 연, 월에 해당하는 폴더를 생성하였다.
블로깅을 오래 하다보면 이미지 파일도 많아질 것이므로 업로드한 시기에 대한 정보로 폴더를 만들면 관리하기 편할 것 같아서 그렇게 만들었다.
아래 그림과 같은 구조가 생겼다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=14NGezpjMa57AwMIg7VSOCgVCY3x2R3p6&quot; alt=&quot;구글 드라이브에 블로그의 이미지 저장소 역할을 할 폴더를 만들었다.&quot; title=&quot;구글 드라이브에 생성한 폴더&quot; /&gt;
    &lt;figcaption&gt;구글 드라이브에 블로그의 이미지 저장소 역할을 할 폴더를 만들었다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 테스트를 위해 무료 이미지 저장소인 &lt;a href=&quot;https://pixabay.com/&quot;&gt;pixabay&lt;/a&gt;에서 임의의 사진을 하나 다운받았다.
맨 앞 페이지에 탁 트인 Grand Canyon 사진이 있길래 &lt;strong&gt;시원하게 열릴 내 미래&lt;/strong&gt;를 상상하며 그 사진을 받았다.&lt;/p&gt;

&lt;p&gt;이 사진을 아까 만들었던 폴더에 올린 후 공개하면 된다.
&lt;strong&gt;그런데 이미지가 여러 개인 경우에는 폴더에 올리고 일일히 공개 설정을 하기보다는, 먼저 폴더를 공개한 후 파일들을 올리는 것이 더 편하다.&lt;/strong&gt;
이미지 파일을 올릴 때마다 공개 설정을 해 줄 필요 없이, 공개 설정을 처음에 한 번만 하면 되기 때문이다.
폴더의 공개 설정은 아래와 같이 할 수 있다.&lt;/p&gt;

&lt;p&gt;먼저 폴더를 우클릭해서 나오는 메뉴 중에서 &lt;strong&gt;공유&lt;/strong&gt;를 클릭한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=16ohcm7sxTQMjEijZi6IwWQSnzJaDALrB&quot; alt=&quot;공개하고 싶은 폴더를 우클릭하고 공유를 선택한다.&quot; title=&quot;구글 드라이브에서 폴더를 공개하기 위한 설정&quot; /&gt;
    &lt;figcaption&gt;공개하고 싶은 폴더를 우클릭하고 공유를 선택한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그러면 아래와 같은 ‘다른 사용자와 공유’라는 제목의 박스가 뜬다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1CqhRpEE9z-ACFgHLTg5rNnkL2oVsvV6X&quot; alt=&quot;공유를 선택하면 '다른 사용자와 공유'라는 박스가 뜬다.&quot; title=&quot;구글 드라이브에서 폴더를 공개하기 위한 설정: 다른 사용자와 공유&quot; /&gt;
    &lt;figcaption&gt;공유를 선택하면 '다른 사용자와 공유'라는 박스가 뜬다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이 박스 오른쪽 하단에 작게 쓰여 있는 &lt;strong&gt;고급&lt;/strong&gt;을 클릭한다.
그러면 이번에는 다시 이렇게 생긴 ‘공유 설정’이라는 제목의 박스가 뜬다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1cd2BIBDdgysKE4UhYWB4qrMTQjfEbjek&quot; alt=&quot;고급을 클릭하면 '공유 설정'이라는 박스로 바뀐다.&quot; title=&quot;구글 드라이브에서 폴더를 공개하기 위한 설정: 공유 설정 이전&quot; /&gt;
    &lt;figcaption&gt;고급을 클릭하면 '공유 설정'이라는 박스로 바뀐다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기에서는 가운데에 있는 &lt;strong&gt;비공개 - 나만 액세스할 수 있습니다.&lt;/strong&gt; 옆에 있는 &lt;strong&gt;변경&lt;/strong&gt;을 클릭한다.
지금은 인증된 기관의 계정으로 로그인된 상태라서 항목의 제목이 &lt;strong&gt;비공개 - 나만 액세스할 수 있습니다.&lt;/strong&gt;라고 표시되었지만 다른 구글 계정에서는 다르게 나타날 수 있다.
어쨌든 &lt;strong&gt;변경&lt;/strong&gt;을 클릭한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1z_xnG0URc3ks5b_P59urBpvj9q1pNCVk&quot; alt=&quot;이어서 뜨는 '링크 공유' 상자에서는 가장 위의 항목을 선택한다.&quot; title=&quot;구글 드라이브에서 폴더를 공개하기 위한 설정: 링크 공유&quot; /&gt;
    &lt;figcaption&gt;이어서 뜨는 '링크 공유' 상자에서는 가장 위의 항목을 선택한다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그러면 이번에는 ‘링크 공유’라는 이름의 박스가 뜬다.
&lt;em&gt;‘창도 많이 뜨고 뭐가 이렇게 복잡하냐’&lt;/em&gt; 생각하겠지만 이게 폴더 공개 설정을 위한 마지막 창이니까 여기까지만 하면 된다.
여기서는 가장 위의 항목인 &lt;strong&gt;사용 - 모든 웹 사용자&lt;/strong&gt;를 선택하면 되는데, 하단에 있는 &lt;strong&gt;모든 사용자의 액세스 범위&lt;/strong&gt;가 &lt;strong&gt;보기만 가능&lt;/strong&gt;이 선택되어 있는 것을 확인해야 한다.
‘수정 가능’ 또는 ‘댓글 작성 가능’ 등이 선택되어 있다면 반드시 &lt;strong&gt;보기만 가능&lt;/strong&gt;으로 바꾸어 준다.
그리고 나서 왼쪽 아래에 있는 &lt;strong&gt;저장&lt;/strong&gt;을 클릭하면 된다.&lt;/p&gt;

&lt;p&gt;그러면 다시 ‘공유 설정’ 박스로 되돌아오게 되는데 아까와는 달리 아래 그림처럼 설정이 바뀌어 있음을 확인할 수 있다.
&lt;strong&gt;웹에 공개 - 인터넷의 모든 사용자가 찾아서 볼 수 있습니다.&lt;/strong&gt;라는 제목으로 변경되었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1vbJKJOPyoyaKccZ2OT3BTxHJvmKNcT5D&quot; alt=&quot;다시 '공유 설정' 상자로 돌아왔는데 액세스 권한이 설정이 바뀌어 있음을 알 수 있다.&quot; title=&quot;구글 드라이브에서 폴더를 공개하기 위한 설정: 공유 설정 이후&quot; /&gt;
    &lt;figcaption&gt;다시 '공유 설정' 상자로 돌아왔는데 액세스 권한이 설정이 바뀌어 있음을 알 수 있다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;여기에서 &lt;strong&gt;완료&lt;/strong&gt;를 클릭해 주면 폴더의 공개를 위한 설정이 모두 끝난다.&lt;/p&gt;

&lt;h1 id=&quot;google-drive에-이미지-업로드&quot;&gt;Google drive에 이미지 업로드&lt;/h1&gt;
&lt;p&gt;이제 공개 설정한 폴더에 아까 다운받았던 Grand Canyon 이미지 파일을 올려보았다.
구글 드라이브에서 위와 같이 폴더를 공개로 설정하고 나면 그 아래에 있는 모든 하위 폴더와 파일들도 같은 설정으로 바뀐다.
따라서 지금은 chobolife 아래에 만들어 둔 연, 월 이름의 폴더도 모두에게 공개된 상태이다.&lt;/p&gt;

&lt;p&gt;chobolife/2019/07 폴더 아래에 Grand Canyon 파일을 올렸다.
파일을 업로드하려면 탐색기에서 파일을 드래그하여 웹브라우저에 올리면 된다.
그렇게 했더니 아래와 같이 제대로 업로드가 되었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1aBXdG0NnnmwX0iPfW5nhyXa1w89M6wmq&quot; alt=&quot;공유 설정을 마치고 이미지 파일을 올린 모습이다.&quot; title=&quot;구글 드라이브에 이미지 파일을 업로드한 모습&quot; /&gt;
    &lt;figcaption&gt;공유 설정을 마치고 이미지 파일을 올린 모습이다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이제 이 이미지 파일의 주소를 얻으면 된다.
이미지 파일 위에서 우클릭한 후 &lt;strong&gt;공유 가능한 링크 가져오기&lt;/strong&gt; 메뉴를 클릭한다.
그러면 이미지 파일 아래에 아래와 같은 툴팁 상자가 생김과 동시에 이미지의 주소가 자동으로 클립보드에 복사된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1z-h2twkk8xEq9oF60CXr-yD0EYLbKFrH&quot; alt=&quot;&quot; title=&quot;&quot; /&gt;
    &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위 툴팁 상자에서는 특별한 설정을 해 줄 것은 없으므로 무시하면 된다.
클립보드에는 아래와 같은 주소가 복사되어 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://drive.google.com/open?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 클립보드에 복사된 주소를 웹브라우저에 입력해 보면 이미지가 그대로 표시되는 것이 아니라 구글의 이미지 뷰어를 통해서 보인다.
아래 그림에서 이미지를 그대로 보여주는 것이 아니라 위와 아래에 별도의 컨트롤러가 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1FSNA_H16E5yAKI21s6_j5e8JtQGHnj0y&quot; alt=&quot;클립보드에 복사된 주소를 그대로 입력하면 구글 드라이브의 자체 뷰어를 통해 이미지가 보인다.&quot; title=&quot;구글 드라이브의 이미지 뷰어&quot; /&gt;
    &lt;figcaption&gt;클립보드에 복사된 주소를 그대로 입력하면 구글 드라이브의 자체 뷰어를 통해 이미지가 보인다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;직접 확인하려면 이 &lt;a href=&quot;https://drive.google.com/open?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot;&gt;링크&lt;/a&gt;를 클릭해도 된다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 문제가 있다.
이미지를 다른 사람에게 보여주기 위해 주소를 그대로 공유할 의도라면 모르겠지만 나는 웹페이지 안에서 이 이미지를 보여주려는 것이기 때문이다.
이렇게 되면 웹페이지 안에서 이미지가 제대로 표시될 수가 없다.&lt;/p&gt;

&lt;p&gt;이것에 대해서 구글링을 해 보았으며 &lt;a href=&quot;http://www.somanet.xyz/2017/06/blog-post_21.html&quot;&gt;이 블로그&lt;/a&gt;에 있는 방법으로 해결하였다.
클립보드에 복사된 주소 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;drive.google.com/&lt;/code&gt; 뒤의 &lt;code class=&quot;highlighter-rouge&quot;&gt;open?id=&lt;/code&gt; 부분을 &lt;code class=&quot;highlighter-rouge&quot;&gt;uc?id=&lt;/code&gt; 로 바꾸어 주면 된다는 것이다.
즉, 단순히 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;uc&lt;/code&gt;로만 바꾸어 주면 되고 나머지 부분은 그대로 둔다.
아래 code block에서 비교해 보자면 원래 클립보드에 복사된 것은 윗줄인데 그것을 아랫줄로 바꾸어 준 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://drive.google.com/open?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe
https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 주소를 웹브라우저에 쳤을 때 이미지가 웹브라우저에 바로 표시된다.
&lt;a href=&quot;https://drive.google.com/uc?id=1L6TXwRoq0KKBREIrG385ckS33_K3YUxe&quot;&gt;링크&lt;/a&gt;를 클릭하여 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이 포스팅에서 소개하지는 않지만 위와 같은 방법으로 동영상도 공유할 수 있다.
방법은 완전히 동일하며, 링크 주소의 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 부분을 그대로 두면 YouTube와 유사한 동영상 플레이어가 실행된다.&lt;/p&gt;

&lt;p&gt;이어서 구글 드라이브에 올린 이미지를 Jekyll에서 표시하는 방법은 다음 포스팅에서 설명할 예정이다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">Jekyll에서 이미지를 올리는 방법에 대해서 찾아보았고, 코드조각이라는 것을 이용하여 나름의 방법을 구축했다. 그 방법을 소개하려고 하는데 그에 앞서 우선 이번 포스팅에서는 Google drive에 이미지 파일을 올리고 웹에 공개하는 방법까지만 작성했다. 그렇게 올린 이미지 파일을 Jekyll post에 표시하는 방법은 다음 포스팅에서 다룰 예정이다.</summary></entry><entry><title type="html">Jekyll로 만든 사이트를 github에 올리기</title><link href="/blog/2019/07/28/jekyll-github/" rel="alternate" type="text/html" title="Jekyll로 만든 사이트를 github에 올리기" /><published>2019-07-28T14:35:00+09:00</published><updated>2019-07-28T14:35:00+09:00</updated><id>/blog/2019/07/28/jekyll-github</id><content type="html" xml:base="/blog/2019/07/28/jekyll-github/">&lt;h1 id=&quot;일단-commit&quot;&gt;일단 commit&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/blog/2019/07/27/start-jekyll-2/&quot;&gt;지난 포스팅 (나의 Jekyll 여행기 (2))&lt;/a&gt;에서 Jekyll을 설치하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;까지 실행해 보았다.
그리고 결과가 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에 생성되는 것을 확인하였다.
그러면 이제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에 생긴 사이트를 웹에 올리는 일만 남았다.
나는 github hosting을 이용하려고 생각하였다.
Github에 올리면 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 명령으로 쉽게 올릴 수도 있고, 도메인도 해결이 되며 어느 정도까지는 무료이다.&lt;/p&gt;

&lt;p&gt;일단 github에 repository를 만들었다.
Repository의 이름은 사용할 github 계정의 이름이자 도메인의 이름과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;chobolife.github.io&lt;/code&gt;라고 생성했다.
Github에 계정을 만들고 난 뒤에 필요한 작업은 다른 포스팅에서 설명할 예정이다. (key를 등록하여 ssh에서 github에 쉽게 접근할 수 있게 하는 설정)&lt;/p&gt;

&lt;p&gt;그리고 command line에서 일단 git을 사용하기 위해 아래와 같은 설정을 해야 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global --edit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Git 자체가 협업을 위한 도구이다보니 사용자의 이름과 이메일 주소를 먼저 입력해야만 작업을 할 수 있다.
위 명령은 그것을 위한 명령이다.&lt;/p&gt;

&lt;p&gt;그런데 이렇게 했더니 nano가 뜬다.
vim에 익숙하고 nano는 전혀 써 본 적이 없기 때문에 나는 이걸 vim으로 바꾸고 싶었다.
물론 이 기회에 nano를 써볼 수 있기도 하겠지만 vim으로 설정을 바꾸는 것이 더 빠르고 편할 것 같아서 vim으로 바꾸었다.
먼저&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;which vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;명령으로 vim의 위치를 알아내었다.
내 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/vim&lt;/code&gt;이다.
그러면&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global core.editor /usr/bin/vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;을 입력한다.
그러면 git의 기본 편집기가 nano에서 vim으로 변경이 된다.
그리고 나서 다시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global --edit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;명령으로 git 사용자 정보를 입력하고 나면 git을 사용할 수 있는 상태가 된다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에 있는 파일들을 github에 올려야 하는데, 우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 파일 하나만 올려보기로 했다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에서 아래와 같은 명령을 수행한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init
git remote add origin git@github.com:chobolife/chobolife.github.io.git
git add index.html
git commit -m &quot;first commit&quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Github repository를 확인해보면 아래와 같다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1cHkHmPgvvGWPW3Ko4K3Bfqfjm9AMd4jG&quot; alt=&quot;웹에서 repository에 들어가 보면 index.html 파일이 정상적으로 commit된 것을 확인할 수 있다.&quot; title=&quot;index.html 파일만 commit한 후의 repository&quot; /&gt;
    &lt;figcaption&gt;웹에서 repository에 들어가 보면 index.html 파일이 정상적으로 commit된 것을 확인할 수 있다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 파일이 잘 올라간 것을 확인할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;웹페이지-올려보기&quot;&gt;웹페이지 올려보기&lt;/h1&gt;
&lt;p&gt;Github repository에 파일은 바로 올라가지만 이것이 웹에 표시되기까지는 시간이 조금 걸리는 것 같다.
잠시 후 주소를 찾아 들어와보니 이렇게 출력된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1Pg_rxdlWfYV0hW3kLDlznJ427Djl-7t3&quot; alt=&quot;index.html 파일만 올리면 웹브라우저에는 볼품없이 표현된다.&quot; title=&quot;index.html만 올렸을 때 웹브라우저에 표현되는 화면&quot; /&gt;
    &lt;figcaption&gt;index.html 파일만 올리면 웹브라우저에는 볼품없이 표현된다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 파일 하나만 올린 상태이기 때문에 css 적용도 안 되어 있고 이래저래 볼품없는 디자인이긴 하다.
하지만 우선 git으로 github에 제대로 올린 것 같다.
이어서 모든 파일을 올려보았다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에서 아래와 같이 수행했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add *
git commit -m &quot;initial files&quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잠시 후 확인해보니 이렇게 표시된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1AX1AeAf128dXraPhdHhRBPzk89iJ8zvw&quot; alt=&quot;site 폴더의 모든 파일을 올리고 Internet Explorer로 보면 그나마 아까보다는 나아진다.&quot; title=&quot;Jekyll을 build한 후 site 폴더의 모든 파일을 올린 뒤 Internet Explorer에 표현되는 첫 페이지&quot; /&gt;
    &lt;figcaption&gt;site 폴더의 모든 파일을 올리고 Internet Explorer로 보면 그나마 아까보다는 나아진다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;잘 된다.
그런데 레이아웃이 조금 겹치고 깨지는 듯한 모습이다.
이게 왜 이러지… 뭔가 테마를 적용해야 하나? 하는 생각을 하는데…
아맞다. Internet Explorer구나.
Internet Explorer 11에서 보면 레이아웃이 위 그림처럼 약간 깨진다.
Chrome에서 보면 아래 그림처럼 잘 보인다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1ntd-LqbNo9iYocR72T8HBrTEfHOy7Me9&quot; alt=&quot;Jekyll의 기본 테마를 Chrome에 띄우고 보면 훨씬 낫다.&quot; title=&quot;Jekyll을 build한 후 site 폴더의 모든 파일을 올린 뒤 Chrome에서 보았을 때의 첫 페이지&quot; /&gt;
    &lt;figcaption&gt;Jekyll의 기본 테마를 Chrome에 띄우고 보면 훨씬 낫다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;아마 Firefox나 Opera 등에서도 잘 보일 것 같다.
Jekyll의 기본 테마는 Edge는 어떨지 모르겠지만 적어도 IE는 지원하지 않는 것 같다.&lt;/p&gt;

&lt;p&gt;자동으로 생성된 첫 번째 포스팅인 &lt;a href=&quot;/blog/2019/07/26/welcome-to-jekyll/&quot;&gt;welcome-to-jekyll&lt;/a&gt;은 삭제하지 않을 예정이다.
스스로 Jekylling을 성공했다는 일종의 기념품이랄까?
왠지 간직하고 싶다.&lt;/p&gt;

&lt;p&gt;그럼 본격적으로 포스팅을 해 보기 위해 이미지를 올리는 방법, 링크 거는 방법, 테마 적용, disqus 삽입 등을 알아봐야겠다. 써 놓고 보니 할 게 많네…
(지금까지의 포스팅은 블로그에 직접 올리고 있는 것이 아니다. 메모장에 글을 기록하고 있다. 아마 다음 작업 이후에 글을 몰아서 올리게 되지 않을까 생각한다.)&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">일단 commit 지난 포스팅 (나의 Jekyll 여행기 (2))에서 Jekyll을 설치하고 jekyll build까지 실행해 보았다. 그리고 결과가 _site 폴더에 생성되는 것을 확인하였다. 그러면 이제는 _site 폴더에 생긴 사이트를 웹에 올리는 일만 남았다. 나는 github hosting을 이용하려고 생각하였다. Github에 올리면 git commit 명령으로 쉽게 올릴 수도 있고, 도메인도 해결이 되며 어느 정도까지는 무료이다.</summary></entry><entry><title type="html">나의 Jekyll 여행기 (2)</title><link href="/blog/2019/07/27/start-jekyll-2/" rel="alternate" type="text/html" title="나의 Jekyll 여행기 (2)" /><published>2019-07-27T18:00:00+09:00</published><updated>2019-07-27T18:00:00+09:00</updated><id>/blog/2019/07/27/start-jekyll-2</id><content type="html" xml:base="/blog/2019/07/27/start-jekyll-2/">&lt;h1 id=&quot;aws에서-시도하다&quot;&gt;AWS에서 시도하다&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/blog/2019/07/26/start-jekyll-1/&quot;&gt;지난 포스팅 (나의 Jekyll 여행기 (1))&lt;/a&gt;에서 했던 실패를 뒤로 하고 나는 계속 Jekyll을 사용할 수 있는 방법을 고민했다.
사실 &lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;Jekyll 홈페이지&lt;/a&gt;에는 Windows에서도 Jekyll을 사용할 수 있는 방법에 대해 나오기는 한다.
하지만 공식적으로 지원하지는 않는 플랫폼이고, 언제 어디서 무슨 문제가 발생할지도 모르는 것이었기 때문에 나는 다른 방법이 가능하면 다른 방법으로 하고 싶었다.
그래서 생각한 방법이 AWS EC2였다.
EC2에 linux instance를 만들고 거기서 설치하면 되지 않을까? 하고 생각했던 것이었다.&lt;/p&gt;

&lt;h1 id=&quot;amazon-linux&quot;&gt;Amazon Linux&lt;/h1&gt;
&lt;p&gt;EC2를 만들 때 기존의 AMI를 기반으로 만들 수 있는데, 이 때 나오는 메뉴는 아래와 같다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1ZphU8Wf-YG5Cv9rXbAvfwa1JYgnHjxcE&quot; alt=&quot;Amazon EC2를 생성할 때 이미 만들어진 템플릿인 AMI를 선택할 수 있다.&quot; title=&quot;Amazon EC2 AMI의 목록&quot; /&gt;
    &lt;figcaption&gt;Amazon EC2를 생성할 때 이미 만들어진 템플릿인 AMI를 선택할 수 있다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그동안 linux instance가 필요할 때면 나는 아무런 생각없이 Amazon Linux 로 시작하는 AMI를 생성했다.
사실 Ubuntu와 Amazon Linux의 차이를 잘 모르고 (알아보려고 한 적도 없다) 그냥 가장 위에 있으니까 썼다.
Amazon이 약간 필요한 대로 수정했을 것이라고만 생각했다.
어쨌든 이번에도 나는 가장 위에 있는 Amazon Linux 2 AMI (HVM), SSD Volume Type으로 만들었다.&lt;/p&gt;

&lt;p&gt;EC2 instance를 만드는 것은 금세 끝난다.
ssh로 접속하고 나서 아까와 마찬가지로 습관처럼 몇 개의 필수 package를 설치한 뒤 Jekyll에 필요한 ruby 관련 package를 설치했다. 이것도 금방 되었다.
그리고 나서 gem에서 jekyll과 bundler를 설치하려고 하니…
이건 또 왠걸.
Jekyll은 ruby 2.1 이상의 버전이 필요한데 여기에 설치되어 있는 ruby의 버전은 2.0이라서 설치를 못한다고 한다.&lt;/p&gt;

&lt;h1 id=&quot;드디어-성공&quot;&gt;드디어 성공&lt;/h1&gt;
&lt;p&gt;그러면 방금 만든 EC2 instance는 재빨리 terminate시키고 이번에는 Ubuntu의 EC2를 설치해 보기로 했다.
어차피 지금까지도 여러 가지 시행착오와 고생을 했는데 한 번 더 하는 걸 못할까?
이번에는 왠지 될 것 같았다.
&lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;Jekyll 공식 홈페이지&lt;/a&gt;에서도 ubuntu에서 설치하는 방법이 나와 있기 때문에 나도 그것과 동일하게 ubuntu에서 설치하려고 하면 잘 될 것 같았다.
사실 cygwin에서 설치를 시도했을 때는 &lt;em&gt;‘되겠지… 설마 안 되겠어?’&lt;/em&gt; 라는 생각이었는데 ubuntu에서는 &lt;em&gt;‘이건 되어야지. 이것도 안 되면 말이 안 되지’&lt;/em&gt; 라는 생각이 들었다.
(결과부터 말하자면 이번에는 설치에 성공했으므로 설치 과정을 간략하게 기록해 두겠다.)&lt;/p&gt;

&lt;p&gt;아까 그림에서 3번째에 있었던 Ubuntu Server 18.04 LTS (HVM), SSD Volume Type 의 EC2를 생성했다.
EC2에 ssh로 접속하고 나서, 익숙한 명령어들을 다시 입력한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 package manager를 업데이트해 주고 나서&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install vim curl git openssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;를 입력하면 필수 package가 설치된다. 그런데 Ubuntu AMI는 이미 필요한 package가 많이 설치되어 있었다.&lt;/p&gt;

&lt;p&gt;그리고 나서 이제 진짜 Jekyll에 필요한 package들을 설치했다.
여기부터는 &lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;Jekyll 공식 홈페이지&lt;/a&gt;에 있는 대로 한 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ruby ruby-dev build-essential
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;어느 정도의 저장 공간이 필요한데 동의하겠느냐고 묻는다.
사뿐히 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;를 누르고 엔터를 치면 본격적으로 설치가 된다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;GEM_HOME&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;를 추가해 준다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo '# Install Ruby Gems to ~/gems' &amp;gt;&amp;gt; ~/.bashrc
echo 'export GEM_HOME=$HOME/gems' &amp;gt;&amp;gt; ~/.bashrc
echo 'export PATH=$HOME/gems/bin:$PATH' &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 되는데 나는 사실 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 파일을 직접 편집했다.
특히 처음 세팅하는 환경에서는 내가 필요한 설정도 해 주어야 하기 때문에 같이 했다.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;에 추가한 후 이제 gem을 이용해서 jekyll을 설치했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll bundler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 이와 같이 설치할 때 중간에 약간 미심쩍은 메세지가 나온다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Fetching: sass-3.7.4.gem (100%)

Ruby Sass has reached end-of-life and should no longer be used.

* If you use Sass as a command-line tool, we recommend using Dart Sass, the new
  primary implementation: https://sass-lang.com/install

* If you use Sass as a plug-in for a Ruby web framework, we recommend using the
  sassc gem: https://github.com/sass/sassc-ruby#readme

* For more details, please refer to the Sass blog:
  https://sass-lang.com/blog/posts/7828841

Successfully installed sass-3.7.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 읽어보면 더 이상 지원되지 않는다는 이야기인 것 같고, 그래도 설치에 실패할 정도로 치명적인 문제는 아닌 것 같다.
마지막에는 아래와 같은 메세지가 출력되며 설치 과정이 끝났다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Done installing documentation for bundler after 3 seconds
26 gems installed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;jekyll-설치-그-이후&quot;&gt;Jekyll 설치, 그 이후&lt;/h1&gt;
&lt;p&gt;Jekyll 설치는 잘 되었다.
다음으로 생각해야 할 것은 Jekyll로 만든 사이트를 &lt;a href=&quot;https://pages.github.com/&quot;&gt;github&lt;/a&gt;이나 &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;AWS S3&lt;/a&gt; 등에 업로드하는 것이다.&lt;/p&gt;

&lt;p&gt;github.io에 하면 호스팅도 자동으로 되고, 무료이며, git으로 commit만 하면 바로 웹에 올릴 수 있기 때문에 편하다.
AWS S3도 정적 웹 호스팅을 쉽게 할 수 있고, 요금이 부과될 정도로 traffic이 발생하지 않는다는 전제 하에 개인 블로그 용도로만 쓰자면 돈이 거의 들지 않으며, 몇 가지 세팅을 해 주면 github처럼 쉽게 할 수 있다.
마지막 세팅에 관해서 엄밀히 말하자면, 안 해봐서 모르지만 쉽게 할 수 있을 &lt;strong&gt;것 같다&lt;/strong&gt;. IAM 역할 설정을 해 주고 AWS cli를 설치해서 이렇게 이렇게 해주면 되겠지…라고 생각만 해 봤는데 직접 해 본 건 아니다.
분명히 그 세팅 과정에서 내 생각대로 한 번에 쭉 될 리가 없다. 어렵거나 복잡할 수도 있으니… 다음에 다른 걸로 대체할 수 없이 꼭 S3를 써야만 할 때 해 보기로 하자.&lt;/p&gt;

&lt;p&gt;어쨌든 나는 github을 이용하기로 마음먹었다.
그러면 github에 어떻게 올릴 수 있는지 한번 부딪혀 봐야겠다.
이것은 시도해 보고 다음 포스팅에 올려야겠다.&lt;/p&gt;

&lt;p&gt;아 그 전에 방금 설치한 Jekyll이 잘 동작하는지 확인해 보자.
처음 환경을 만들었다면 Hello World라도 출력해 보는 것이 인지상정 아니겠는가.&lt;/p&gt;

&lt;h1 id=&quot;jekyll-동작-확인&quot;&gt;Jekyll 동작 확인&lt;/h1&gt;
&lt;p&gt;Jekyll 공식 홈페이지에 있는 &lt;a href=&quot;https://jekyllrb-ko.github.io/docs/quickstart/&quot;&gt;빠른시작 설명서&lt;/a&gt;, &lt;a href=&quot;https://jekyllrb-ko.github.io/docs/usage/&quot;&gt;기본 사용법&lt;/a&gt;을 참고해서 진행했다.
먼저 home 디렉토리에서 아래와 같이 입력했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new chobolife
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그러면 아래와 같은 아름다운 로그가 출력된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Running bundle install in /home/ubuntu/chobolife...
  Bundler: Fetching gem metadata from https://rubygems.org/..............
  Bundler: Fetching gem metadata from https://rubygems.org/..
  Bundler: Resolving dependencies...
  Bundler: Using public_suffix 3.1.1
  Bundler: Using addressable 2.6.0
  Bundler: Using bundler 2.0.2
  Bundler: Using colorator 1.1.0
  Bundler: Using concurrent-ruby 1.1.5
  Bundler: Using eventmachine 1.2.7
  Bundler: Using http_parser.rb 0.6.0
  Bundler: Using em-websocket 0.5.1
  Bundler: Using ffi 1.11.1
  Bundler: Using forwardable-extended 2.6.0
  Bundler: Using i18n 0.9.5
  Bundler: Using rb-fsevent 0.10.3
  Bundler: Using rb-inotify 0.10.0
  Bundler: Using sass-listen 4.0.0
  Bundler: Using sass 3.7.4
  Bundler: Using jekyll-sass-converter 1.5.2
  Bundler: Using ruby_dep 1.5.0
  Bundler: Using listen 3.1.5
  Bundler: Using jekyll-watch 2.2.1
  Bundler: Using kramdown 1.17.0
  Bundler: Using liquid 4.0.3
  Bundler: Using mercenary 0.3.6
  Bundler: Using pathutil 0.16.2
  Bundler: Using rouge 3.7.0
  Bundler: Using safe_yaml 1.0.5
  Bundler: Using jekyll 3.8.6
  Bundler: Fetching jekyll-feed 0.12.1
  Bundler: Installing jekyll-feed 0.12.1
  Bundler: Fetching jekyll-seo-tag 2.6.1
  Bundler: Installing jekyll-seo-tag 2.6.1
  Bundler: Fetching minima 2.5.0
  Bundler: Installing minima 2.5.0
  Bundler: Bundle complete! 6 Gemfile dependencies, 29 gems now installed.
  Bundler: Use `bundle info [gemname]` to see where a bundled gem is installed.
New jekyll site installed in /home/ubuntu/chobolife.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;제대로 된 것일까? 일단 home 디렉토리 밑에 chobolife라는 디렉토리가 새로 생겼다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd chobolife&lt;/code&gt; 명령으로 새로 생긴 디렉토리에 들어가서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ll&lt;/code&gt; 명령을 쳐 보면 이렇게 나온다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;total 40
drwxrwxr-x 3 ubuntu ubuntu 4096 Jul 26 23:50 ./
drwxr-xr-x 9 ubuntu ubuntu 4096 Jul 26 23:49 ../
-rw-r--r-- 1 ubuntu ubuntu   35 Jul 26 23:49 .gitignore
-rw-r--r-- 1 ubuntu ubuntu  398 Jul 26 23:49 404.html
-rw-rw-r-- 1 ubuntu ubuntu 1119 Jul 26 23:49 Gemfile
-rw-rw-r-- 1 ubuntu ubuntu 1871 Jul 26 23:50 Gemfile.lock
-rw-r--r-- 1 ubuntu ubuntu 1652 Jul 26 23:49 _config.yml
drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 26 23:49 _posts/
-rw-r--r-- 1 ubuntu ubuntu  539 Jul 26 23:49 about.md
-rw-r--r-- 1 ubuntu ubuntu  175 Jul 26 23:49 index.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아직 Jekyll의 구조나 원리에 대해서는 아무 것도 모르지만 뭔가 잘 된 것 같다. 기분이 편안하다.
그러면 여기서 아래 명령으로 Jekyll을 간단하게 실행해 보자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 입력하니 Jekyll이 무언가 일을 한 것 같다. 이번에는 아래와 같이 출력되었다. 역시 마음이 편안하다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Configuration file: /home/ubuntu/chobolife/_config.yml
            Source: /home/ubuntu/chobolife
       Destination: /home/ubuntu/chobolife/_site
 Incremental build: disabled. Enable with --incremental
      Generating...
       Jekyll Feed: Generating feed for posts
                    done in 0.395 seconds.
 Auto-regeneration: disabled. Use --watch to enable.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;뭐가 달라진 게 있을까? &lt;code class=&quot;highlighter-rouge&quot;&gt;ll&lt;/code&gt; 명령으로 다시 한번 무엇이 바뀌었는지 확인해 보았다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;total 48
drwxrwxr-x 5 ubuntu ubuntu 4096 Jul 26 23:51 ./
drwxr-xr-x 9 ubuntu ubuntu 4096 Jul 26 23:49 ../
-rw-r--r-- 1 ubuntu ubuntu   35 Jul 26 23:49 .gitignore
drwxrwxr-x 4 ubuntu ubuntu 4096 Jul 26 23:51 .sass-cache/
-rw-r--r-- 1 ubuntu ubuntu  398 Jul 26 23:49 404.html
-rw-rw-r-- 1 ubuntu ubuntu 1119 Jul 26 23:49 Gemfile
-rw-rw-r-- 1 ubuntu ubuntu 1871 Jul 26 23:50 Gemfile.lock
-rw-r--r-- 1 ubuntu ubuntu 1652 Jul 26 23:49 _config.yml
drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 26 23:49 _posts/
drwxrwxr-x 5 ubuntu ubuntu 4096 Jul 26 23:51 _site/
-rw-r--r-- 1 ubuntu ubuntu  539 Jul 26 23:49 about.md
-rw-r--r-- 1 ubuntu ubuntu  175 Jul 26 23:49 index.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확실히 무언가 바뀌었다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 명령 후에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.sass-cache&lt;/code&gt; 디렉토리와 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리가 새로 생긴 것을 알 수 있다.
그리고 조금 더 자세히 살펴보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 디렉토리 아래 깊숙한 곳에 &lt;code class=&quot;highlighter-rouge&quot;&gt;welcome-to-jekyll.html&lt;/code&gt; 파일이 생성되었다.
이 파일을 vim으로 열어보면 Jekyll의 설치 및 작동에는 문제가 없는 것 같다.
Hello World를 출력해 보지는 않았지만 별다른 에러 메시지가 없고 파일이 잘 생성되는 것으로 봐서 이번에는 성공한 것 같다.&lt;/p&gt;

&lt;p&gt;그러면 이제 이렇게 생성된 html 파일을 배포하는 방법을 고민해 봐야겠다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">AWS에서 시도하다 지난 포스팅 (나의 Jekyll 여행기 (1))에서 했던 실패를 뒤로 하고 나는 계속 Jekyll을 사용할 수 있는 방법을 고민했다. 사실 Jekyll 홈페이지에는 Windows에서도 Jekyll을 사용할 수 있는 방법에 대해 나오기는 한다. 하지만 공식적으로 지원하지는 않는 플랫폼이고, 언제 어디서 무슨 문제가 발생할지도 모르는 것이었기 때문에 나는 다른 방법이 가능하면 다른 방법으로 하고 싶었다. 그래서 생각한 방법이 AWS EC2였다. EC2에 linux instance를 만들고 거기서 설치하면 되지 않을까? 하고 생각했던 것이었다.</summary></entry><entry><title type="html">나의 Jekyll 여행기 (1)</title><link href="/blog/2019/07/26/start-jekyll-1/" rel="alternate" type="text/html" title="나의 Jekyll 여행기 (1)" /><published>2019-07-26T18:00:00+09:00</published><updated>2019-07-26T18:00:00+09:00</updated><id>/blog/2019/07/26/start-jekyll-1</id><content type="html" xml:base="/blog/2019/07/26/start-jekyll-1/">&lt;h1 id=&quot;jekyll의-시작&quot;&gt;Jekyll의 시작&lt;/h1&gt;
&lt;p&gt;블로그를 시작하려고 한다. 아마 나의 이런저런 생각들, 그리고 내가 했던 것들을 기록하기 위한 용도로 사용할 것 같다.
그리고 나는 여러 가지 방법을 알아보고 나서, Jekyll을 사용해 보기로 했다.&lt;/p&gt;

&lt;p&gt;일반 포털 사이트에서 제공하는 블로그는 자유도가 낮아 새로운 것을 시도해보기 어렵기 때문에 처음부터 별로 생각이 없었다.
그리고 다음으로 생각했던 것은 전에도 써 본 적이 있었던 설치형 워드프레스였는데, 워드프레스는 장점도 많지만 단점도 여럿 있다.
결국 워드프레스인가… 하고 생각하면서 계속 찾아보니 Jekyll이라는 것을 통해 정적 웹사이트를 만들 수 있다는데, 이 Jekyll이 나의 호기심을 자극했다. 그래서 한 번 Jekyll을 사용해 보기로 했다.&lt;/p&gt;

&lt;p&gt;솔직히 말하자면 블로그를 해야겠다고 생각한 것보다 Jekyll을 써 보고 싶다는 생각이 먼저였다.
블로그는 Jekyll을 써먹어보기 위해 하는 것에 가깝다.
대부분의 개발자는 나의 생각을 이해할 것이다.
뭔가 하고 싶은 게 먼저 있어서 그것을 구현하기 위한 기술을 찾아보는 절차도 있지만, 역순으로 어떤 기술을 먼저 접하고 그것을 활용해 보고 싶어서 내가 직접 해보는 절차도 있다는 것이다.&lt;/p&gt;

&lt;p&gt;블로그를 하는 목적이랄까. 블로그를 시작하며 내가 생각한 바는 있는데 이 포스팅은 아니고 아마 다른 기회에 그것을 쓰면 좋을 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;jekyll-설치-그리고-첫-번째-실패&quot;&gt;Jekyll 설치, 그리고 첫 번째 실패&lt;/h1&gt;
&lt;p&gt;나는 Windows 환경에서 cygwin을 사용하고 있었기 때문에 여기에 Jekyll을 설치해서 사용하려고 했다.
Jekyll의 설치는 &lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;Jekyll 공식 홈페이지&lt;/a&gt;를 참고했다.&lt;/p&gt;

&lt;p&gt;Cygwin 설치 파일을 실행하면 package list가 아래처럼 주르륵 나온다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;https://drive.google.com/uc?id=1Txs5i_3Vq_l8MLrLnJkvnneiYkHlYDvy&quot; alt=&quot;Cygwin 설치 과정에서 package list를 만나게 된다.&quot; title=&quot;Cygwin 설치 과정의 package list&quot; /&gt;
    &lt;figcaption&gt;Cygwin 설치 과정에서 package list를 만나게 된다.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림은 category 기준으로 보이는데, 잘 보면 Ruby도 발견할 수 있다.
그 중에서 이미 설치되어 있는 package를 찾아서 삭제할 수 있고 설치되어 있지 않는 package를 찾아서 새로 설치할 수도 있다.
여기에서 나는 ruby, ruby-devel을 설치했다.
원래 공식 홈페이지에는 ubuntu linux에서 설치할 때 ruby, ruby-dev, build-essential를 설치하라고 되어 있었는데 cygwin package list에서는 ruby-dev가 없는 대신 ruby-devel이 있었고, build-essential은 아예 없었다.
그것을 대체할만한 다른 package가 있겠지만 잘 모르니까 일단 위의 2개만 설치해 보았다.&lt;/p&gt;

&lt;p&gt;그렇게 순조롭게 설치한 후 Jekyll을 설치하다가 아래와 같은 문제에 봉착했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
Building native extensions.  This could take a while...
      1 [main] ruby 6344 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xE30000)
      1 [main] ruby 11208 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xE40000)
      1 [main] ruby 20176 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xE40000)
      2 [main] ruby 18388 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xDF0000)
      2 [main] ruby 10036 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xE00000)
      1 [main] ruby 17064 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0x650000)
      2 [main] ruby 10300 child_info_fork::abort: C:\cygwin\bin\cyggmp-10.dll: Loaded to different address: parent(0x690000) != child(0xC30000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 abort가 발생했다.
당연히 Jekyll의 설치는 제대로 되지 않았다.
Stackoverflow 등 구글링을 해 보면 다른 사람들도 이와 같은 문제를 겪었다는 것을 알 수 있다. 그런데 이렇다할 뾰족한 방법이 없었다.
정확히 말하자면 답변으로 달린 방법은 몇 개 있었지만 내가 직접 해 보니 다 제대로 된 해결법은 아니었다.&lt;/p&gt;

&lt;p&gt;그렇다면 Jekyll은 cygwin에서 사용할 수 없는 것일까? 그건 아닐 거라고 생각했다.
나는 이번에 cygwin에 처음 ruby 및 그와 관련된 package를 설치한 것이지만, cygwin은 워낙 사용자가 많아서 package 자체에 문제가 있는 것은 아닐 것이고, 어떤 이유로 인해 내가 기존에 쓰던 환경에서 꼬이지 않았을까 생각했다.&lt;/p&gt;

&lt;p&gt;그래서 나는 &lt;strong&gt;과감하게&lt;/strong&gt; cygwin을 재설치했다.
Cygwin에는 내가 그동안 개발해 오면서 많은 것들을 설치하고 나에 맞게끔 설정한 것이 많기 때문에 그것은 매우 과감한 결정이었다.
이것 역시 개발자들은 이해할 것이다. 환경을 바꾸는 것이 얼마나 과감하고 그리고 무모한 일인지.
Cygwin 설치에 대한 것은 조금 자세하게 다음에 포스팅할 예정이다.
똑같은 삽질이라도 다음번에는 더 빠르게 하기 위해서 기록을 남길 필요는 있다.&lt;/p&gt;

&lt;h1 id=&quot;두-번째-실패&quot;&gt;두 번째 실패&lt;/h1&gt;
&lt;p&gt;어쨌든, cygwin을 삭제 후 다시 설치했다.
이번에는 cygwin 설치 파일을 실행했을 때 나오는 package list에서 설치하지 않고, cygwin에 package manager인 apt-cyg를 설치한 후 그 package manager에서 ruby를 설치해 보기로 했다.
어차피 cygwin의 자체 package list를 통해서 설치한다면 아까와 동일하게 ruby, ruby-devel을 설치하게 될 텐데, 그러면 결과도 왠지 똑같을 것 같았기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brunch.co.kr/@davisasan/37&quot;&gt;이 블로그&lt;/a&gt;를 참고해서 apt-cyg를 설치했다.
맨 처음 cygwin을 설치할 때에는 package list 중에서 다른 것은 모두 무시하고 wget만 깔았다.
그리고 cygwin의 설치가 다 되면 아래와 같은 명령으로 apt-cyg를 설치할 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget raw.github.com/transcode-open/apt-cyg/master/apt-cyg
chmod +x apt-cyg
mv apt-cyg /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;보면 알겠지만 누군가 올려 놓은 apt-cyg를 github에서 받아와서, 권한 설정한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt; 폴더에 넣어주는 것이다.
위와 같이 해서 apt-cyg를 설치하고 나면 apt-cyg를 통해서 다른 필요한 package를 설치할 수 있다.&lt;/p&gt;

&lt;p&gt;습관인지 아니면 본능인지 모르겠지만 command line에서 뭘 하든 필수라고 할 수 있는 package들을 가장 먼저 설치했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-cyg update
apt-cyg install vim curl git openssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 다음부터는 또 Jekyll의 설치법을 따라서 그대로 진행했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-cyg install ruby ruby-dev build-essential
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 주르륵 길게 로그가 출력되면서 열심히 설치한다. 그런데 불길하게 그 중에 이런 문구가 나타난다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Installing ruby-dev
Unable to locate package ruby-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아마도 ruby-dev가 제대로 설지되지 않았다는 말일 것 같은데… 일단 무시하고 설치를 계속했다.
(왜 불길한 예감은 항상 틀리지 않는 것일까…)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;GEM_HOME&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;를 설정하고 나서 gem을 통해 Jekyll을 설치해 보았다.
(Jekyll의 구체적인 설치 과정은 &lt;a href=&quot;/blog/2019/07/27/start-jekyll-2/&quot;&gt;다음 포스팅 (나의 Jekyll 여행기 (2))&lt;/a&gt;에서 다루었다.)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll bundler
Fetching: public_suffix-3.1.1.gem (100%)
Successfully installed public_suffix-3.1.1
Fetching: addressable-2.6.0.gem (100%)
Successfully installed addressable-2.6.0
Fetching: colorator-1.1.0.gem (100%)
Successfully installed colorator-1.1.0
Fetching: http_parser.rb-0.6.0.gem (100%)
Building native extensions.  This could take a while...
ERROR:  Error installing jekyll:
        ERROR: Failed to build gem native extension.

    current directory: /home/sb.lee/.gem/ruby/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser
/usr/bin/ruby.exe -r ./siteconf20190727-17252-bha32i.rb extconf.rb
mkmf.rb can't find header files for ruby at /usr/share/ruby/include/ruby.h

extconf failed, exit code 1

Gem files will remain installed in /home/sb.lee/.gem/ruby/2.3.0/gems/http_parser.rb-0.6.0 for inspection.
Results logged to /home/sb.lee/.gem/ruby/2.3.0/extensions/x86-cygwin/2.3.0/http_parser.rb-0.6.0/gem_make.out
Fetching: bundler-2.0.2.gem (100%)
Successfully installed bundler-2.0.2
Parsing documentation for bundler-2.0.2
Installing ri documentation for bundler-2.0.2
Done installing documentation for bundler after 16 seconds
1 gem installed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 로그를 잘 보면 bundler는 제대로 설치가 되었는데 Jekyll을 설치하지 못했다.
이래서는 cygwin에서 Jekyll을 쓸 수가 없지 않을까?
처음 cygwin을 재설치하고 나서부터 진행했던 것이기 때문에 이번에는 package끼리 꼬인다거나 다른 문제가 발생할 소지가 없었기 때문이다.&lt;/p&gt;

&lt;p&gt;이렇게 Jekyll을 설치하려고 했던 나의 첫 시도는 내게 익숙했던 개발 환경만 허망하게 날린 채 아무런 결과를 내지 못했다.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">Jekyll의 시작 블로그를 시작하려고 한다. 아마 나의 이런저런 생각들, 그리고 내가 했던 것들을 기록하기 위한 용도로 사용할 것 같다. 그리고 나는 여러 가지 방법을 알아보고 나서, Jekyll을 사용해 보기로 했다.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="/blog/2019/07/26/welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2019-07-26T07:00:00+09:00</published><updated>2019-07-26T07:00:00+09:00</updated><id>/blog/2019/07/26/welcome-to-jekyll</id><content type="html" xml:base="/blog/2019/07/26/welcome-to-jekyll/">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>